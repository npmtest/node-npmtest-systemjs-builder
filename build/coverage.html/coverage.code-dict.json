{"/home/travis/build/npmtest/node-npmtest-systemjs-builder/test.js":"/* istanbul instrument in package npmtest_systemjs_builder */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-systemjs-builder/lib.npmtest_systemjs_builder.js":"/* istanbul instrument in package npmtest_systemjs_builder */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_systemjs_builder = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_systemjs_builder = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-systemjs-builder/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-systemjs-builder && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_systemjs_builder */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_systemjs_builder\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_systemjs_builder.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_systemjs_builder.rollup.js'] =\n            local.assetsDict['/assets.npmtest_systemjs_builder.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_systemjs_builder.__dirname + '/lib.npmtest_systemjs_builder.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/index.js":"module.exports = require('./lib/builder');\n","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/lib/builder.js":"var Promise = require('bluebird');\nvar System = require('systemjs');\n\nvar asp = require('bluebird').promisify;\nvar fs = require('fs');\nvar path = require('path');\n\nvar extend = require('./utils').extend;\n\nvar attachCompilers = require('./compile').attachCompilers;\nvar compileTree = require('./compile').compileTree;\nvar compileLoad = require('./compile').compileLoad;\nvar pluginBundleHook = require('./compile').pluginBundleHook;\nvar writeOutputs = require('./output').writeOutputs;\n\nvar traceExpression = require('./arithmetic').traceExpression;\n\nvar Trace = require('./trace');\n\nvar getCanonicalName = require('./utils').getCanonicalName;\n\nvar fromFileURL = require('./utils').fromFileURL;\nvar toFileURL = require('./utils').toFileURL;\n\nvar createHash = require('crypto').createHash;\nvar getFormatHint = require('./utils').getFormatHint;\n\n// new Builder(baseURL)\n// new Builder({cfg})\n// new Builder(baseURL, {cfg})\n// new Builder(baseURL, 'cfg-file.js')\n//\n// baseURL is ignored in cfg when given\n// cfg is saved and used by reset\nfunction Builder(baseURL, cfg) {\n  if (typeof baseURL == 'object') {\n    cfg = baseURL;\n    baseURL = null;\n  }\n\n  this.loader = null;\n  this.resetConfig = function() {};\n\n  this.reset();\n\n  if (baseURL)\n    this.config({ baseURL: baseURL });\n\n  // config passed to constructor will\n  // be saved for future .reset() calls\n  if (typeof cfg == 'object')\n    this.config(cfg, true, !!baseURL);\n  else if (typeof cfg == 'string')\n    this.loadConfigSync(cfg, true, !!baseURL);\n}\n\n// invalidate the cache for a given module name\n// accepts wildcards (*) which are taken to be deep-matching\nBuilder.prototype.invalidate = function(invalidationModuleName) {\n  var loader = this.loader;\n\n  var invalidated = [];\n\n  var self = this;\n\n  // invalidation happens in normalized-space\n  invalidationModuleName = loader.decanonicalize(invalidationModuleName);\n\n  // wildcard detection and handling\n  var invalidationWildcardIndex = invalidationModuleName.indexOf('*');\n  if (invalidationModuleName.lastIndexOf('*') != invalidationWildcardIndex)\n    throw new TypeError('Only a single wildcard supported for invalidation.');\n\n  if (invalidationWildcardIndex != -1) {\n    var wildcardLHS = invalidationModuleName.substr(0, invalidationWildcardIndex);\n    var wildcardRHS = invalidationModuleName.substr(invalidationWildcardIndex + 1);\n  }\n\n  function matchesInvalidation(moduleName) {\n    if (moduleName == invalidationModuleName)\n      return true;\n\n    if (invalidationWildcardIndex == -1)\n      return false;\n\n    return moduleName.substr(0, invalidationWildcardIndex) == wildcardLHS\n        && moduleName.substr(moduleName.length - wildcardRHS.length) == wildcardRHS;\n  }\n\n  // invalidate the given path in the trace cache\n  var traceCache = this.cache.trace;\n  Object.keys(traceCache).forEach(function(canonical) {\n    var moduleName = loader.decanonicalize(canonical);\n    if (matchesInvalidation(moduleName)) {\n      if (traceCache[canonical])\n        invalidated.push(moduleName);\n      traceCache[canonical] = undefined;\n    }\n  });\n\n  // clear the given path from the pluginLoader registry\n  var pluginLoader = loader.pluginLoader;\n  Object.keys(pluginLoader._loader.modules).forEach(function(moduleName) {\n    if (matchesInvalidation(moduleName)) {\n      invalidated.push(moduleName);\n      pluginLoader.delete(moduleName);\n    }\n  });\n\n  // clear the loader define cache\n  loader.defined = {};\n\n  // we leave the compile cache in-tact as it is hashed\n\n  // return array of invalidated canonicals\n  return invalidated;\n};\n\nBuilder.prototype.reset = function(baseLoader) {\n  baseLoader = baseLoader || this.loader || System;\n\n  var loader = this.loader = new baseLoader.constructor();\n  // make builder accessible in plugins\n  loader.builder = this;\n  // put the loader in the builder environment\n  loader.config({ build: true });\n\n  loader.import = function(name) {\n    return Promise.reject(new Error('Unable to import \"' + name + '\".\\nThe incorrect instance of System is being used to System.import.'));\n  };\n\n  // ensure this loader doesn't attempt to load the runtime\n  loader._loader.loadedTranspilerRuntime = true;\n\n  var pluginLoader = loader.pluginLoader = new baseLoader.constructor();\n  pluginLoader.config({ build: true });\n\n  loader.constructor = pluginLoader.constructor = baseLoader.constructor;\n  loader.baseURL = pluginLoader.baseURL = baseLoader.baseURL;\n\n  loader.normalize = pluginLoader.normalize = baseLoader.normalize;\n  loader.normalizeSync = pluginLoader.normalizeSync = baseLoader.normalizeSync;\n\n  // store original hooks for next reset\n  loader.originalHooks = baseLoader.originalHooks || {\n    locate: baseLoader.locate,\n    fetch: baseLoader.fetch,\n    translate: baseLoader.translate,\n    instantiate: baseLoader.instantiate\n  };\n\n  loader.locate = pluginLoader.locate = loader.originalHooks.locate;\n  loader.fetch = pluginLoader.fetch = loader.originalHooks.fetch;\n  loader.translate = pluginLoader.translate = loader.originalHooks.translate;\n  loader.instantiate = pluginLoader.instantiate = loader.originalHooks.instantiate;\n\n  var loaderConfig = loader.config;\n  loader.config = function(cfg) {\n    // plugin loader is dev, Node environment\n    loader.pluginLoader.config(cfg);\n    var lCfg = extend({}, cfg);\n    loaderConfig.call(this, lCfg);\n    loader.configHash = generateConfigHash(loader);\n  };\n\n  this.getCanonicalName = getCanonicalName.bind(null, this.loader);\n  this.loader.getCanonicalName = this.loader.pluginLoader.getCanonicalName = this.getCanonicalName;\n\n  attachCompilers(loader);\n\n  var builder = this;\n\n  // allow a custom fetch hook\n  var loaderFetch = loader.fetch;\n  var cachedFetch = function(load) {\n    return Promise.resolve(loaderFetch.call(this, load))\n    .then(function(source) {\n      // calling default fs.readFile fetch -> set timestamp as well for cache invalidation\n      return asp(fs.stat)(fromFileURL(load.address))\n      .then(function(stats) {\n        load.metadata.timestamp = stats.mtime.getTime();\n        return source;\n      }, function(err) {\n        // if the stat fails on a plugin, it may not be linked to the file itself\n        if (err.code == 'ENOENT' && load.metadata.loader)\n          return source;\n        throw err;\n      });\n    });\n  };\n\n  loader.fetch = function(load) {\n    if (builder.fetch)\n      return Promise.resolve(builder.fetch.call(this, load, cachedFetch.bind(this)));\n    else\n      return cachedFetch.call(this, load);\n  };\n\n  // this allows us to normalize package conditionals into package conditionals\n  // package environment normalization handling for fallbacks,\n  // which dont resolve in the loader itself unlike other conditionals which\n  // have this condition inlined under loader.builder in conditionals.js\n  var loaderNormalize = loader.normalize;\n  loader.normalize = function(name, parentName, parentAddress) {\n    var pkgConditional;\n    var pkgConditionalIndex = name.indexOf('/#:');\n    if (pkgConditionalIndex != -1) {\n      pkgConditional = name.substr(pkgConditionalIndex);\n      name = name.substr(0, pkgConditionalIndex + 1);\n    }\n    return loaderNormalize.call(this, name, parentName, parentAddress)\n    .then(function(normalized) {\n      if (pkgConditional)\n        normalized = normalized + pkgConditional;\n      return normalized;\n    });\n  };\n\n  var loaderNormalizeSync = loader.normalizeSync;\n  loader.normalizeSync = function(name, parentName, parentAddress) {\n    var pkgConditional;\n    var pkgConditionalIndex = name.indexOf('#:');\n    if (pkgConditionalIndex != -1) {\n      pkgConditional = name.substr(pkgConditionalIndex);\n      name = name.substr(0, pkgConditionalIndex) + '/';\n    }\n    var normalized = loaderNormalizeSync.call(this, name, parentName, parentAddress);\n    if (pkgConditional)\n      normalized = normalized.substr(0, normalized.length - 1) + pkgConditional;\n    return normalized;\n  };\n\n  // run saved configuration functions against new loader instance\n  this.resetConfig();\n\n  // create cache if not existing\n  this.setCache(this.cache || {});\n\n  // mark all traces as unfresh\n  var traceCache = this.cache.trace;\n  Object.keys(traceCache).forEach(function(canonical) {\n    if (traceCache[canonical])\n      traceCache[canonical].fresh = false;\n  });\n};\n\nfunction generateConfigHash(loader) {\n  return createHash('md5')\n  .update(JSON.stringify({\n    paths: loader.paths,\n    packages: loader.packages,\n    meta: loader.meta,\n    map: loader.map\n  }))\n  .digest('hex');\n}\n\nBuilder.prototype.setCache = function(cacheObj) {\n  this.cache = {\n    compile: cacheObj.compile || {},\n    trace: cacheObj.trace || {}\n  };\n  this.cache.compile.encodings = this.cache.compile.encodings || {};\n  this.cache.compile.loads = this.cache.compile.loads || {};\n  this.tracer = new Trace(this.loader, this.cache.trace);\n};\n\nBuilder.prototype.getCache = function() {\n  return this.cache;\n};\n\nBuilder.prototype.clearCache = function() {\n  this.setCache({});\n};\n\nfunction executeConfigFile(saveForReset, ignoreBaseURL, configPath, source) {\n  var self = this;\n\n  // create a safe loader to give to the config execution\n  var configLoader = Object.create(this.loader);\n  configLoader.config = function(cfg) {\n    self.config(cfg, saveForReset, ignoreBaseURL);\n  };\n\n  // make everything in global available to config file code\n  // only substitute local copy of System\n  // and prevent that code from adding anything to the real global\n  var context = Object.create(global);\n  context.SystemJS = context.System = configLoader;\n  context.global = context;\n  if (process.versions.node && process.versions.node.split('.')[0] < 6)\n    context.GLOBAL = context.root = context;\n  // make require available too, make it look as if config file was\n  // loaded like a module\n  var Module = require('module');\n  var m = new Module(configPath);\n  m.filename = configPath;\n  m.paths = Module._nodeModulePaths(path.dirname(configPath));\n  context.require = m.require.bind(m);\n  require('vm').runInNewContext(source.toString(), context);\n}\n\nBuilder.prototype.loadConfig = function(configFile, saveForReset, ignoreBaseURL) {\n  return asp(fs.readFile)(configFile)\n  .then(executeConfigFile.bind(this, saveForReset, ignoreBaseURL, configFile));\n};\n\nBuilder.prototype.loadConfigSync = function(configFile, saveForReset, ignoreBaseURL) {\n  var source = fs.readFileSync(configFile);\n  executeConfigFile.call(this, saveForReset, ignoreBaseURL, configFile, source);\n};\n\n// note ignore argument is part of API\nBuilder.prototype.config = function(config, saveForReset, ignoreBaseURL) {\n  var cfg = {};\n  for (var p in config) {\n    if (ignoreBaseURL && p == 'baseURL' || p == 'bundles' || p == 'depCache')\n      continue;\n    cfg[p] = config[p];\n  }\n  this.loader.config(cfg);\n  if (saveForReset) {\n    // multiple config calls can be saved for reset\n    var curReset = this.resetConfig;\n    this.resetConfig = function() {\n      curReset.call(this);\n      this.loader.config(cfg);\n    };\n  }\n};\n\n/*\n * Builder Operations\n */\nfunction processTraceOpts(options, defaults) {\n  var opts = {\n    // indicate to plugins to output ES modules instead of System.register for Rollup support\n    outputESM: true,\n    sourceMaps: false,\n\n    // conditional tracing options\n    browser: undefined,\n    node: undefined,\n    production: undefined,\n    dev: undefined,\n    conditions: {\n      '@system-env|default': true,\n      '@system-env|~default': false\n    },\n    inlineConditions: {},\n    traceRuntimePlugin: true,\n\n    // package config tracing (used for bundles only)\n    tracePackageConfig: false,\n\n    // when set, automatically excludes non-file URLs that don't resolve to canonical names\n    // instead of showing the \"Unable to calculate canonical name\" error\n    excludeURLs: true,\n    externals: []\n  };\n\n  // ensure user environment overrides default environment\n  if (typeof options == 'object') {\n    if (typeof options.browser == 'boolean' || typeof options.node == 'boolean') {\n      // browser true/false -> node is opposite\n      if (typeof options.browser == 'boolean' && typeof options.node != 'boolean')\n        options.node = !options.browser;\n      // node true/false -> browser is opposite\n      else if (typeof options.node == 'boolean' && typeof options.browser != 'boolean')\n        options.browser = !options.node;\n    }\n\n    // development -> dev backwards compat\n    if ('development' in options)\n      options.dev = options.development;\n    if (typeof options.dev == 'boolean' || typeof options.production == 'boolean') {\n      if (typeof options.production != 'boolean')\n        options.production = !options.dev;\n      if (typeof options.dev != 'boolean')\n        options.dev = !options.production;\n    }\n  }\n\n  extend(opts, defaults);\n  extend(opts, options);\n\n  // globalDeps are externals\n  if (opts.globalDeps)\n    opts.externals = opts.externals.concat(Object.keys(opts.globalDeps));\n\n  // conditional tracing defaults\n  if (typeof opts.browser == 'boolean') {\n    // browser, node   -> browser, ~browser, node, ~node\n    // !browser, node  -> ~browser, node\n    // browser, !node  -> browser, ~node\n    // !browser, !node -> ~browser, ~node\n    opts.conditions['@system-env|browser'] = opts.browser;\n    opts.conditions['@system-env|~browser'] = opts.browser === true ? opts.node : !opts.browser;\n    opts.conditions['@system-env|node'] = opts.node;\n    opts.conditions['@system-env|~node'] = opts.node === true ? opts.browser : !opts.node;\n  }\n  if (typeof opts.production == 'boolean') {\n    opts.conditions['@system-env|production'] = opts.production;\n    opts.conditions['@system-env|~production'] = opts.dev;\n    opts.conditions['@system-env|dev'] = opts.dev;\n    opts.conditions['@system-env|~dev'] = opts.production;\n  }\n\n  if (typeof opts.inlineConditions == 'object')\n    extend(opts.conditions, opts.inlineConditions);\n  else if (opts.inlineConditions === true)\n    opts.inlineConditions = opts.conditions;\n  else\n    opts.inlineConditions = {};\n\n  return opts;\n}\n\nBuilder.prototype.trace = function(expression, opts) {\n  if (opts && opts.config)\n    this.config(opts.config);\n\n  var traceOpts = processTraceOpts(opts);\n  var self = this;\n  return canonicalizeConditions(self.loader, traceOpts)\n  .then(function() {\n    return setExternals(this, traceOpts.externals);\n  })\n  .then(function() {\n    return traceExpression(self, expression, traceOpts);\n  });\n};\n\nBuilder.prototype.traceConditionalEnv = function(expression, opts) {\n  var traceOpts = processTraceOpts(opts);\n\n  var self = this;\n\n  return canonicalizeConditions(self.loader, traceOpts)\n  .then(function() {\n    return self.trace(expression, traceOpts);\n  })\n  .then(function(tree) {\n    return Trace.getConditionalEnv(self, tree, traceOpts);\n  });\n}\n\nfunction processCompileOpts(options, defaults) {\n  // NB deprecate these warnings\n  // all of the below features were undocumented and experimental, so deprecation needn't be long\n  options = options || {};\n  if ('sfxFormat' in options) {\n    console.warn('SystemJS Builder \"sfxFormat\" is deprecated and has been renamed to \"format\".');\n    options.format = options.sfxFormat;\n  }\n  if ('sfxEncoding' in options) {\n    console.warn('SystemJS Builder \"sfxEncoding\" is deprecated and has been renamed to \"encodeNames\".');\n    options.encodeNames = sfxEncoding;\n  }\n  if ('sfxGlobals' in options) {\n    console.warn('SystemJS Builder \"sfxGlobals\" is deprecated and has been renamed to \"globalDeps\".');\n    options.globalDeps = options.sfxGlobals;\n  }\n  if ('sfxGlobalName' in options) {\n    console.warn('SystemJS Builder \"sfxGlobalName\" is deprecated and has been renamed to \"globalName\".');\n    options.globalName = options.sfxGlobalName;\n  }\n\n  var opts = {\n    entryPoints: [],\n    normalize: false,\n    anonymous: false,\n\n    systemGlobal: 'System',\n    // whether to inline package configurations into bundles\n    buildConfig: false,\n    inlinePlugins: true,\n    static: false,\n    encodeNames: undefined,\n\n    sourceMaps: false,\n    lowResSourceMaps: false,\n\n    // static build options\n    // it may make sense to split this out into build options\n    // at a later point as static build and bundle compile diverge further\n    runtime: false,\n    format: 'umd',\n    globalDeps: {},\n    globalName: null,\n    exportDefault: false,\n    // conditionalResolutions: {},\n    // can add a special object here that matches condition predicates to direct module names to use for sfx\n\n    // set to true to build in \"format amd\" style sfx hints for SystemJS loading\n    formatHint: false,\n\n    // this shouldn't strictly be a compile option (its a trace option)\n    // but the cjs compiler needs it to do NODE_ENV optimization\n    production: undefined,\n\n    // use rollup optimizations\n    rollup: true\n  };\n\n  extend(opts, defaults);\n  extend(opts, options);\n\n  if (options.encodeNames && (!'encodeNames' in defaults))\n    throw new Error('encodeNames is only supported for buildStatic.');\n\n  if (typeof opts.production != 'boolean')\n    opts.production = !opts.development;\n\n  if (opts.static) {\n    if (opts.encodeNames !== false)\n      opts.encodeNames = true;\n    // include runtime by default if needed\n    if (options.runtime !== false)\n      opts.runtime = true;\n\n    // static builds have a System closure with a dummy name\n    opts.systemGlobal = '$__System';\n\n    // static builds normalize all requires\n    opts.normalize = true;\n  }\n\n  return opts;\n}\n\nBuilder.prototype.compile = function(moduleNameOrLoad, outFile, opts) {\n  if (outFile && typeof outFile == 'object') {\n    opts = outFile;\n    outFile = undefined;\n  }\n\n  if (opts && opts.config)\n    this.config(opts.config);\n\n  var self = this;\n\n  var traceOpts = processTraceOpts(opts, { tracePackageConfig: false, browser: true, node: false, production: true, dev: false, outputESM: false });\n\n  return Promise.resolve()\n  .then(function() {\n    return canonicalizeConditions(self.loader, traceOpts);\n  })\n  .then(function() {\n    if (typeof moduleNameOrLoad != 'string')\n      return moduleNameOrLoad;\n    return self.loader.normalize(moduleNameOrLoad)\n    .then(function(moduleName) {\n      if (!opts || opts.cache !== true)\n        self.invalidate(moduleName);\n      return self.tracer.getLoadRecord(getCanonicalName(self.loader, moduleName), traceOpts);\n    });\n  })\n  .then(function(load) {\n    var compileOpts = processCompileOpts(opts, { normalize: false, anonymous: true });\n    var outputOpts = processOutputOpts(opts, { outFile: outFile });\n\n    return Promise.resolve()\n    .then(function() {\n      return compileLoad(self.loader, load, processCompileOpts(opts, { normalize: false, anonymous: true }), self.cache.compile);\n    })\n    .then(function(output) {\n      if (load.metadata.loader)\n        return pluginBundleHook(self.loader, [load], compileOpts, outputOpts)\n        .then(function(bundleOutput) {\n          return [output].concat(bundleOutput.outputs);\n        });\n\n      return [output];\n    })\n    .then(function(outputs) {\n      return writeOutputs(outputs, self.loader.baseURL, outputOpts);\n    });\n  });\n};\n\nfunction processOutputOpts(options, defaults) {\n  var opts = {\n    outFile: undefined,\n\n    minify: false,\n    uglify: undefined,\n    mangle: true,\n\n    sourceMaps: false,\n    sourceMapContents: undefined\n  };\n\n  extend(opts, defaults);\n  extend(opts, options);\n\n  opts.uglify = opts.uglify || {};\n  opts.uglify.compress = opts.uglify.compress || {};\n  opts.uglify.beautify = opts.uglify.beautify || {};\n\n  // NB deprecated these for uglify directly\n  if (opts.globalDefs && !('global_defs' in opts.uglify.compress))\n    opts.uglify.compress.global_defs = opts.globalDefs;\n  if (opts.ascii && !('ascii' in opts.uglify.beautify))\n    opts.uglify.beautify.ascii_only = opts.ascii;\n  delete opts.globalDefs;\n  delete opts.ascii;\n\n  if (!('dead_code' in opts.uglify.compress))\n    opts.uglify.compress.dead_code = true;\n  if (!('warnings' in opts.uglify.compress))\n    opts.uglify.compress.warnings = false;\n\n  // source maps 'inline' handling\n  if (opts.sourceMapContents === undefined)\n    opts.sourceMapContents = opts.sourceMaps == 'inline';\n\n  if (opts.sourceMapContents)\n    opts.uglify.sourceMapIncludeSources = true;\n\n  return opts;\n}\n\nfunction setExternals(builder, externals) {\n  if (!externals)\n    return Promise.resolve();\n  var externalMeta;\n  return Promise.all(externals.map(function(external) {\n    externalMeta = externalMeta || {};\n    return builder.loader.normalize(external)\n    .then(function(normalizedExternal) {\n      externalMeta[normalizedExternal] = { build: false };\n    });\n  }))\n  .then(function() {\n    if (externalMeta)\n      builder.config({\n        meta: externalMeta\n      });\n  });\n}\n\nfunction canonicalizeConditions(loader, traceOpts) {\n  return Promise.resolve(Trace.toCanonicalConditionalEnv(loader, traceOpts.conditions))\n  .then(function(canonicalConditionalEnv) {\n    traceOpts.conditions = canonicalConditionalEnv;\n\n    return Trace.toCanonicalConditionalEnv(loader, traceOpts.inlineConditions);\n  })\n  .then(function(canonicalInlineConditionalEnv) {\n    traceOpts.inlineConditions = canonicalInlineConditionalEnv;\n\n    return traceOpts;\n  });\n}\n\n// bundle\nBuilder.prototype.bundle = function(expressionOrTree, outFile, opts) {\n  if (outFile && typeof outFile === 'object') {\n    opts = outFile;\n    outFile = undefined;\n  }\n\n  var self = this;\n\n  if (opts && opts.config)\n    this.config(opts.config);\n\n  var outputOpts = processOutputOpts(opts, { outFile: outFile });\n  // by default we bundle for the browser in production\n  var traceOpts = processTraceOpts(opts, { tracePackageConfig: true, browser: true, node: false, production: true, dev: false });\n\n  var compileOpts = processCompileOpts(opts);\n\n  // override the fetch function if given\n  if (opts && opts.fetch)\n    this.fetch = opts.fetch;\n\n  return Promise.resolve()\n  .then(function() {\n    return canonicalizeConditions(self.loader, traceOpts);\n  })\n  .then(function() {\n    if (typeof expressionOrTree != 'string' && !(expressionOrTree instanceof Array))\n      return expressionOrTree;\n\n    return setExternals(self, traceOpts.externals)\n    .then(function() {\n      return traceExpression(self, expressionOrTree, traceOpts);\n    });\n  })\n  .then(function(tree) {\n    return Promise.resolve()\n    .then(function() {\n      if (compileOpts.inlineConditions)\n        return self.tracer.inlineConditions(tree, self.loader, traceOpts);\n      return tree;\n    })\n    .then(function(tree) {\n      return compileTree(self.loader, tree, traceOpts, compileOpts, outputOpts, self.cache.compile)\n      .then(function(compiled) {\n        return writeOutputs(compiled.outputs, self.loader.baseURL, outputOpts)\n        .then(function(output) {\n          output.modules = compiled.modules;\n          output.entryPoints = compiled.entryPoints;\n          output.tree = tree;\n          output.assetList = compiled.assetList;\n          if (outputOpts.outFile) {\n            try {\n              output.bundleName = self.getCanonicalName(toFileURL(path.resolve(outputOpts.outFile)));\n            }\n            catch(e) {}\n          }\n          return output;\n        });\n      });\n    });\n  });\n};\n\n// build into an optimized static module\nBuilder.prototype.buildStatic = function(expressionOrTree, outFile, opts) {\n  if (outFile && typeof outFile === 'object') {\n    opts = outFile;\n    outFile = undefined;\n  }\n\n  var self = this;\n\n  if (opts && opts.config)\n    this.config(opts.config);\n\n  // NB this \"first module\" detection should really be done at the arithmetic level\n  // if only one module is provided, it is an entry point\n  var entryPoints;\n  if (typeof expressionOrTree == 'string')\n    entryPoints = [expressionOrTree.split(/ [\\+\\&\\-] /)[0]];\n  else if (expressionOrTree instanceof Array)\n    entryPoints = expressionOrTree[0];\n  else\n    entryPoints = [];\n  // ensure globs are not themsleves entry points\n  if (entryPoints[0] && entryPoints[0].indexOf('*') != -1)\n    entryPoints = [];\n\n  var outputOpts = processOutputOpts(opts, { outFile: outFile });\n  // by default we build for production, but not necessarily the browser\n  var traceOpts = processTraceOpts(opts, { tracePackageConfig: false, production: true, dev: false });\n  var compileOpts = processCompileOpts(opts, { static: true, entryPoints: entryPoints, encodeNames: true });\n  var inlineMap;\n\n  // override the fetch function if given\n  if (opts && opts.fetch)\n    this.fetch = opts.fetch;\n\n  return Promise.resolve()\n  .then(function() {\n    return canonicalizeConditions(self.loader, traceOpts);\n  })\n  .then(function() {\n    if (typeof expressionOrTree != 'string' && !(expressionOrTree instanceof Array))\n      return expressionOrTree;\n\n    return setExternals(self, traceOpts.externals)\n    .then(function() {\n      return traceExpression(self, expressionOrTree, traceOpts);\n    });\n  })\n  .then(function(tree) {\n    // inline conditionals of the trace\n    return self.tracer.inlineConditions(tree, self.loader, traceOpts)\n    .then(function(inlinedTree) {\n      if (!compileOpts.rollup)\n        return compileTree(self.loader, inlinedTree, traceOpts, compileOpts, outputOpts, self.cache.compile);\n\n      var rollupTree = require('./rollup').rollupTree;\n\n      // attempt rollup optimizations of ESM entry points\n      return rollupTree(self.loader, inlinedTree, [], traceOpts, compileOpts, outputOpts)\n      .then(function(rolledUp) {\n        inlineMap = rolledUp.inlineMap;\n\n        // we rolled up parts of the tree\n        if (rolledUp.tree)\n          return compileTree(self.loader, rolledUp.tree, traceOpts, compileOpts, outputOpts, self.cache.compile);\n\n        // if we rolled up the whole tree, then we can skip compile and sfx wrapping entirely\n        else if (rolledUp.outputs)\n          return {\n            outputs: (compileOpts.formatHint ? [getFormatHint(compileOpts)] : []).concat(rolledUp.outputs),\n            assetList: rolledUp.assetList\n          };\n      })\n      .then(function(compiled) {\n        return {\n          modules: Object.keys(tree).filter(function(m) {\n            return tree[m] && !tree[m].conditional;\n          }),\n          assetList: compiled.assetList || [],\n          outputs: compiled.outputs\n        };\n      })\n    })\n    .then(function(compiled) {\n      return writeOutputs(compiled.outputs, self.loader.baseURL, outputOpts)\n      .then(function(output) {\n        if (inlineMap)\n          output.inlineMap = inlineMap;\n        output.assetList = compiled.assetList;\n        output.modules = compiled.modules;\n        output.tree = tree;\n        return output;\n      });\n    });\n  });\n};\n\nBuilder.prototype.build = function() {\n  console.warn('builder.build is deprecated. Using builder.bundle instead.');\n  return this.bundle.apply(this, arguments);\n};\nBuilder.prototype.buildSFX = function() {\n  console.warn('builder.buildSFX is deprecated. Using builder.buildStatic instead.');\n  return this.buildStatic.apply(this, arguments);\n};\nBuilder.prototype.buildTree = function() {\n  console.warn('builder.buildTree is deprecated. Using builder.bundle instead, which takes both a tree object or expression string.');\n  return this.bundle.apply(this, arguments);\n};\n\n// given a tree, creates a depCache for it\nBuilder.prototype.getDepCache = function(tree) {\n  var depCache = {};\n  Object.keys(tree).forEach(function(moduleName) {\n    var load = tree[moduleName];\n    if (load && load.deps && load.deps.length)\n      depCache[moduleName] = load.deps.map(function(dep) {\n        return dep;\n      });\n  });\n  return depCache;\n};\n\nBuilder.prototype.getDeferredImports = function(tree) {\n  var getDeferredImports = require('./get-deferred-imports');\n  return getDeferredImports(this, tree);\n}\n\n// expose useful tree statics on the builder instance for ease-of-use\nBuilder.prototype.intersectTrees = require('./arithmetic').intersectTrees;\nBuilder.prototype.addTrees = require('./arithmetic').addTrees;\nBuilder.prototype.subtractTrees = require('./arithmetic').subtractTrees;\n\nmodule.exports = Builder;\n","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/lib/utils.js":"var path = require('path');\nvar url = require('url');\n\nexports.traceurGet = function(module) {\n  var traceur = require('traceur');\n  var traceurVersion = traceur.loader.NodeTraceurLoader.prototype.version;\n  return $traceurRuntime.ModuleStore.get('traceur@' + traceurVersion + '/src/' + module);\n};\n\nexports.extend = extend;\nfunction extend(a, b) {\n  for (var p in b)\n    a[p] = b[p];\n  return a;\n}\n\nexports.dextend = dextend;\nfunction dextend(a, b) {\n  for (var p in b) {\n    if (!b.hasOwnProperty(p))\n      continue;\n    var val = b[p];\n    if (typeof val === 'object')\n      dextend(a[p] = typeof a[p] === 'object' ? a[p] : {}, val);\n    else\n      a[p] = val;\n  }\n  return a;\n}\n\nexports.getFormatHint = getFormatHint;\nfunction getFormatHint(compileOpts) {\n  var formatHint = '';\n\n  var format = compileOpts.format;\n\n  if (format == 'umd')\n    format = 'amd';\n\n  if (format == 'amd' || format == 'cjs' || format == 'global')\n    formatHint = formatHint + '\"format ' + format + '\";\\n';\n\n  if (compileOpts.format == 'global') {\n    for (var g in compileOpts.globalDeps)\n      formatHint = formatHint + '\"globals.' + compileOpts.globalDeps[g] + ' ' + g + '\";\\n';\n\n    if (compileOpts.globalName)\n      formatHint = formatHint + '\"exports ' + compileOpts.globalName + '\";\\n';\n  }\n\n  return formatHint;\n}\n\nvar isWin = process.platform.match(/^win/);\n\nexports.fromFileURL = fromFileURL;\nfunction fromFileURL(url) {\n  return url.substr(7 + !!isWin).replace(/\\//g, path.sep);\n}\n\nexports.toFileURL = toFileURL;\nfunction toFileURL(path) {\n  return 'file://' + (isWin ? '/' : '') + path.replace(/\\\\/g, '/');\n}\n\nexports.getAlias = getAlias\nfunction getAlias(loader, canonicalName) {\n  var pluginIndex = loader.pluginFirst ? canonicalName.indexOf('!') : canonicalName.lastIndexOf('!');\n  if (pluginIndex != -1)\n    return getAlias(loader, canonicalName.substr(0, pluginIndex)) + '!' + getAlias(loader, canonicalName.substr(pluginIndex + 1));\n\n  // replace subpath conditionals with subpath\n  canonicalName = canonicalName.replace('/#:./', '/');\n\n  if (canonicalName.match(/\\#[\\:\\{\\?]/))\n    throw new Error('Unable to alias the conditional dependency \"' + canonicalName + '\".');\n\n  var packageName = getPackage(loader.packages, loader.decanonicalize(canonicalName));\n  var packageMain = packageName && loader.packages[packageName].main;\n  if (packageMain && canonicalName.substr(canonicalName.length - packageMain.length - 1) == '/' + packageMain)\n    canonicalName = canonicalName.substr(0, canonicalName.length - packageMain.length - 1);\n\n  var bestAliasLength = 0;\n  var bestAliasSubpath;\n  var bestAlias;\n  Object.keys(loader.map).forEach(function(alias) {\n    if (alias.split('/').length <= bestAliasLength)\n      return;\n\n    // get mapped without defaultJSExtension\n    var mapped = getCanonicalName(loader, loader.decanonicalize(loader.map[alias]));\n\n    // do matching with defaultJSExtension checking\n    if (loader.defaultJSExtensions && canonicalName == mapped + '.js') {\n      bestAlias = alias;\n      bestAliasSubpath = '';\n      bestAliasLength = alias.split('/').length;\n    }\n    else if (canonicalName.substr(0, mapped.length) == mapped && \n        (canonicalName.length == mapped.length || canonicalName[mapped.length] == '/')) {\n      bestAlias = alias;\n      bestAliasSubpath = canonicalName.substr(mapped.length);\n      bestAliasLength = alias.split('/').length;\n    }\n  });\n\n  if (bestAlias)\n    return bestAlias + bestAliasSubpath;\n\n  return canonicalName;\n}\n\nexports.verifyTree = verifyTree;\nfunction verifyTree(tree) {\n  if (typeof tree != 'object' || tree instanceof Array)\n    throw new TypeError('Expected a trace tree object');\n\n  Object.keys(tree).forEach(function(key) {\n    var load = tree[key];\n    if (typeof load === 'boolean')\n      return;\n    if (load && typeof load != 'object' || !load.name || !(load.conditional || load.deps))\n      throw new TypeError('Expected a trace tree object, but \"' + key + '\" is not a load record.');\n  });\n}\n\nexports.getCanonicalName = getCanonicalName;\nfunction getCanonicalName(loader, normalized, isPlugin) {\n  // 1. Boolean conditional\n  var booleanIndex = normalized.lastIndexOf('#?');\n  if (booleanIndex != -1) {\n    var booleanModule = normalized.substr(booleanIndex + 2);\n    var negate = booleanModule[0] == '~';\n    if (negate)\n      booleanModule = booleanModule.substr(1);\n    return getCanonicalName(loader, normalized.substr(0, booleanIndex)) + '#?' + (negate ? '~' : '') + canonicalizeCondition(loader, booleanModule);\n  }\n\n  // 2. Plugins\n  var pluginIndex = loader.pluginFirst ? normalized.indexOf('!') : normalized.lastIndexOf('!');\n  if (pluginIndex != -1)\n    return getCanonicalName(loader, normalized.substr(0, pluginIndex), !loader.pluginFirst) + '!' + getCanonicalName(loader, normalized.substr(pluginIndex + 1), loader.pluginFirst);\n\n  // 3. Package environment map\n  var pkgEnvIndex = normalized.indexOf('/#:');\n  if (pkgEnvIndex != -1)\n    return getCanonicalName(loader, normalized.substr(0, pkgEnvIndex), isPlugin) + '/#:' + normalized.substr(pkgEnvIndex + 3);\n\n  // Finally get canonical plain\n  var canonical = getCanonicalNamePlain(loader, normalized, isPlugin);\n\n  // 4. Canonicalize conditional interpolation\n  var conditionalMatch = canonical.match(interpolationRegEx);\n  if (conditionalMatch)\n    return getCanonicalNamePlain(loader, normalized, isPlugin).replace(interpolationRegEx, '#{' + canonicalizeCondition(loader, conditionalMatch[0].substr(2, conditionalMatch[0].length - 3)) + '}');\n\n  return canonical;\n}\n\n// calculate the canonical name of the normalized module\n// unwraps loader syntaxes to derive component parts\nvar interpolationRegEx = /#\\{[^\\}]+\\}/;\nfunction canonicalizeCondition(loader, conditionModule) {\n  var conditionExport;\n  var exportIndex = conditionModule.lastIndexOf('|');\n  if (exportIndex != -1) {\n    conditionExport = conditionModule.substr(exportIndex + 1)\n    conditionModule = conditionModule.substr(0, exportIndex) || '@system-env';\n  }\n  return getCanonicalName(loader, conditionModule) + (conditionExport ? '|' + conditionExport : '');\n}\n\n// syntax-free getCanonicalName\n// just reverse-applies paths and defulatJSExtension to determine the canonical\nfunction getCanonicalNamePlain(loader, normalized, isPlugin) {\n  // now just reverse apply paths rules to get canonical name\n  var pathMatch;\n\n  // first check exact path matches\n  for (var p in loader.paths) {\n    if (loader.paths[p].indexOf('*') != -1)\n      continue;\n\n    var curPath = normalizePath(loader, loader.paths[p], isPlugin);\n\n    // always stop on first exact match\n    if (normalized === curPath)\n      return p;\n\n    // support trailing / in paths rules\n    else if (curPath[curPath.length - 1] == '/' &&\n        normalized.substr(0, curPath.length - 1) == curPath.substr(0, curPath.length - 1) && \n        (normalized.length < curPath.length || normalized[curPath.length - 1] == curPath[curPath.length - 1])) {\n      // first case is that canonicalize('src') = 'app' for 'app/': 'src/'\n      return normalized.length < curPath.length ? p.substr(0, p.length - 1) : p + normalized.substr(curPath.length);\n    }\n  }\n\n  // then wildcard matches\n  var pathMatchLength = 0;\n  var curMatchLength;\n  if (!pathMatch)\n    for (var p in loader.paths) {\n      if (loader.paths[p].indexOf('*') == -1)\n        continue;\n\n      // normalize the output path\n      var curPath = normalizePath(loader, loader.paths[p], true);\n\n      // do reverse match\n      var wIndex = curPath.indexOf('*');\n      if (normalized.substr(0, wIndex) === curPath.substr(0, wIndex)\n        && normalized.substr(normalized.length - curPath.length + wIndex + 1) === curPath.substr(wIndex + 1)) {\n        curMatchLength = curPath.split('/').length;\n        if (curMatchLength >= pathMatchLength) {\n          pathMatch = p.replace('*', normalized.substr(wIndex, normalized.length - curPath.length + 1));\n          pathMatchLength = curMatchLength;\n        }\n      }\n    }\n\n  // when no path was matched, act like the standard rule is *: baseURL/*\n  if (!pathMatch) {\n    if (normalized.substr(0, loader.baseURL.length) == loader.baseURL)\n      pathMatch = normalized.substr(loader.baseURL.length);\n    else if (normalized.match(absURLRegEx))\n      throw new Error('Unable to calculate canonical name to bundle ' + normalized + '. Ensure that this module sits within the baseURL or a wildcard path config.');\n    else\n      pathMatch = normalized;\n  }\n\n  return pathMatch;\n}\n\nexports.getPackageConfigPath = getPackageConfigPath;\n\n// check if the given normalized name matches a packageConfigPath\n// if so, loads the config\nvar packageConfigPaths = {};\n\n// data object for quick checks against package paths\nfunction createPkgConfigPathObj(path) {\n  var lastWildcard = path.lastIndexOf('*');\n  var length = Math.max(lastWildcard + 1, path.lastIndexOf('/'));\n  return {\n    length: length,\n    // NB handle regex control character escapes or simply create a test function here\n    regEx: new RegExp('^(' + path.substr(0, length).replace(/\\*/g, '[^\\\\/]+') + ')(\\\\/|$)'),\n    wildcard: lastWildcard != -1\n  };\n}\n\n// most specific match wins\nexports.getPackageConfigPath = getPackageConfigPath;\nfunction getPackageConfigPath(packageConfigPaths, normalized) {\n  var pkgName, exactMatch = false, configPath;\n  for (var i = 0; i < packageConfigPaths.length; i++) {\n    var packageConfigPath = packageConfigPaths[i];\n    var p = packageConfigPaths[packageConfigPath] || (packageConfigPaths[packageConfigPath] = createPkgConfigPathObj(packageConfigPath));\n    if (normalized.length < p.length)\n      continue;\n    var match = normalized.match(p.regEx);\n    if (match && (!pkgName || (!(exactMatch && p.wildcard) && pkgName.length < match[1].length))) {\n      pkgName = match[1];\n      exactMatch = !p.wildcard;\n      configPath = pkgName + packageConfigPath.substr(p.length);\n    }\n  }\n\n  if (!pkgName)\n    return;\n\n  // return value is only part modified from SystemJS implementation of getPackageConfigMatch\n  return configPath;\n}\n\n// determine whether the given module name is a package config file\nexports.isPackageConfig = isPackageConfig;\nvar curHash;\nvar configPathCache = null;\nvar canonicalConfigPaths = null;\nfunction isPackageConfig(loader, canonical) {\n  if (loader.configHash != curHash) {\n    configPathCache = null;\n    curHash = loader.configHash;\n  }\n\n  // generate canonical packageConfigPaths for matching\n  if (!configPathCache) {\n    canonicalConfigPaths = loader.packageConfigPaths.map(function(configPath) {\n      return getCanonicalName(loader, configPath);\n    });\n    configPathCache = {};\n  }\n\n  if (canonical in configPathCache)\n    return configPathCache[canonical];\n\n  // check if the given canonical matches the canonical package config paths\n  var cfgPathMatch = getPackageConfigPath(canonicalConfigPaths, canonical);\n  configPathCache[canonical] = cfgPathMatch && cfgPathMatch.split('/').length == canonical.split('/').length;\n\n  return configPathCache[canonical];\n}\n\nexports.getPackage = getPackage;\nfunction getPackage(packages, name) {\n  // use most specific package\n  var curPkg, curPkgLen = 0, pkgLen;\n  for (var p in packages) {\n    if (name.substr(0, p.length) === p && (name.length === p.length || name[p.length] === '/')) {\n      pkgLen = p.split('/').length;\n      if (pkgLen > curPkgLen) {\n        curPkg = p;\n        curPkgLen = pkgLen;\n      }\n    }\n  }\n  return curPkg;\n}\n\nvar absURLRegEx = /^[^\\/]+:\\/\\//;\nfunction normalizePath(loader, path, skipExtension) {\n  var curMap = loader.map;\n  var curPaths = loader.paths;\n  var curPackages = loader.packages;\n  loader.map = {};\n  loader.paths = {};\n  loader.packages = {};\n  var normalized = loader.normalizeSync(path);\n  if (skipExtension && path.substr(path.length - 3, 3) != '.js' && normalized.substr(normalized.length - 3, 3) == '.js')\n    normalized = normalized.substr(0, normalized.length - 3);\n  loader.map = curMap;\n  loader.paths = curPaths;\n  loader.packages = curPackages;\n  return normalized;\n}\n\nvar sysConditions = ['browser', 'node', 'dev', 'production', 'default'];\n\nexports.parseCondition = parseCondition;\nfunction parseCondition(condition) {\n  var conditionExport, conditionModule, negation;\n\n  var negation = condition[0] == '~';\n  var conditionExportIndex = condition.lastIndexOf('|');\n  if (conditionExportIndex != -1) {\n    conditionExport = condition.substr(conditionExportIndex + 1);\n    conditionModule = condition.substr(negation, conditionExportIndex - negation);\n\n    if (conditionExport[0] == '~') {\n      negation = true;\n      conditionExport = conditionExport.substr(1);\n    }\n  }\n  else {\n    conditionExport = 'default';\n    conditionModule = condition.substr(negation);\n    if (sysConditions.indexOf(conditionModule) != -1) {\n      conditionExport = conditionModule;\n      conditionModule = '@system-env';\n    }\n  }\n\n  return {\n    module: conditionModule,\n    prop: conditionExport,\n    negate: negation\n  };\n}\n\nexports.serializeCondition = serializeCondition;\nfunction serializeCondition(conditionObj) {\n  return conditionObj.module + '|' + (conditionObj.negate ? '~' : '') + conditionObj.prop;\n}\n\n","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/lib/compile.js":"var Promise = require('bluebird');\nvar asp = require('bluebird').promisify;\nvar fs = require('fs');\nvar path = require('path');\nvar url = require('url');\nvar createHash = require('crypto').createHash;\nvar template = require('es6-template-strings');\nvar getAlias = require('./utils').getAlias;\nvar extend = require('./utils').extend;\nvar traverseTree = require('./arithmetic').traverseTree;\nvar verifyTree = require('./utils').verifyTree;\nvar getFormatHint = require('./utils').getFormatHint;\n\nvar compilerMap = {\n  'amd': '../compilers/amd',\n  'cjs': '../compilers/cjs',\n  'esm': '../compilers/esm',\n  'global': '../compilers/global',\n  'system': '../compilers/register',\n  'json': '../compilers/json'\n};\n\n// create a compile hash based on path + source + metadata + compileOpts\n// one implication here is that plugins shouldn't rely on System.x checks\n// as these will not be cache-invalidated but within the bundle hook is fine\nfunction getCompileHash(load, compileOpts) {\n  return createHash('md5')\n  .update(JSON.stringify({\n    source: load.source,\n    metadata: load.metadata,\n    path: compileOpts.sourceMaps && load.path,\n\n    normalize: compileOpts.normalize,\n    anonymous: compileOpts.anonymous,\n    systemGlobal: compileOpts.systemGlobal,\n    static: compileOpts.static,\n    encodeNames: compileOpts.encodeNames,\n    sourceMaps: compileOpts.sourceMaps,\n    lowResSourceMaps: compileOpts.lowResSourceMaps\n  }))\n  .digest('hex');\n}\n\nfunction getEncoding(canonical, encodings, loader) {\n  // dont encode system modules\n  if (canonical[0] == '@' && canonical != '@dummy-entry-point' && loader.has(canonical))\n    return canonical;\n\n  // return existing encoding if present\n  if (encodings[canonical])\n    return encodings[canonical];\n\n  // search for the first available key\n  var highestEncoding = 9;\n  Object.keys(encodings).forEach(function(canonical) {\n    var encoding = encodings[canonical];\n    highestEncoding = Math.max(parseInt(encoding, '16'), highestEncoding);\n  });\n\n  highestEncoding++;\n\n  return encodings[canonical] = highestEncoding.toString(16);\n}\nfunction getName(encoding, encodings) {\n  var match\n  Object.keys(encodings).some(function(e) {\n    if (encodings[e] == encoding) {\n      match = e;\n      return true;\n    }\n  });\n  return match;\n}\n\n// used to support leading #!/usr/bin/env in scripts as supported in Node\nvar hashBangRegEx = /^\\#\\!.*/;\n\nexports.compileLoad = compileLoad;\nfunction compileLoad(loader, load, compileOpts, cache) {\n  // use cached if we have it\n  var cached = cache.loads[load.name];\n  if (cached && cached.hash == getCompileHash(load, compileOpts))\n    return Promise.resolve(cached.output);\n\n  // create a new load record with any necessary final mappings\n  function remapLoadRecord(load, mapFunction) {\n    load = extend({}, load);\n    load.name = mapFunction(load.name, load.name);\n    var depMap = {};\n    Object.keys(load.depMap).forEach(function(dep) {\n      depMap[dep] = mapFunction(load.depMap[dep], dep);\n    });\n    load.depMap = depMap;\n    return load;\n  }\n  var mappedLoad = remapLoadRecord(load, function(name, original) {\n    // do SFX encodings\n    if (compileOpts.encodeNames)\n      return getEncoding(name, cache.encodings, loader);\n\n    if (compileOpts.normalize && name.indexOf('#:') != -1)\n      throw new Error('Unable to build dependency ' + name + '. normalize must be disabled for bundles containing conditionals.');\n\n    return name;\n  });\n\n  var format = load.metadata.format;\n\n  if (format == 'defined')\n    return Promise.resolve({ source:  compileOpts.systemGlobal + '.register(\"' + mappedLoad.name + '\", [], function() { return { setters: [], execute: function() {} } });\\n' });\n\n  if (format in compilerMap) {\n    if (format == 'cjs')\n      mappedLoad.source = mappedLoad.source.replace(hashBangRegEx, '');\n    return Promise.resolve()\n    .then(function() {\n      return require(compilerMap[format]).compile(mappedLoad, compileOpts, loader);\n    })\n    .then(function(output) {\n      // store compiled output in cache\n      cache.loads[load.name] = {\n        hash: getCompileHash(load, compileOpts),\n        output: output\n      };\n\n      return output;\n    })\n    .catch(function(err) {\n      // Traceur has a habit of throwing array errors\n      if (err instanceof Array)\n        err = err[0];\n      err.message = 'Error compiling ' + format + ' module \"' + load.name + '\" at ' + load.path + '\\n\\t' + err.message;\n      throw err;\n    });\n  }\n\n  return Promise.reject(new TypeError('Unknown module format ' + format));\n}\n\n// sort in reverse pre-order, filter modules to actually built loads (excluding conditionals, build: false)\n// (exported for unit testing)\nexports.getTreeModulesPostOrder = getTreeModulesPostOrder;\nfunction getTreeModulesPostOrder(tree, traceOpts) {\n  var entryPoints = [];\n\n  // build up the map of parents of the graph\n  var entryMap = {};\n\n  var moduleList = Object.keys(tree).filter(function(module) {\n    return tree[module] !== false;\n  }).sort();\n\n  // for each module in the tree, we traverse the whole tree\n  // we then relate each module in the tree to the first traced entry point\n  moduleList.forEach(function(entryPoint) {\n    traverseTree(tree, entryPoint, function(depName, parentName) {\n      // if we have a entryMap for the given module, then stop\n      if (entryMap[depName])\n        return false;\n\n      if (parentName)\n        entryMap[depName] = entryPoint;\n    }, traceOpts);\n  });\n\n  // the entry points are then the modules not represented in entryMap\n  moduleList.forEach(function(entryPoint) {\n    if (!entryMap[entryPoint])\n      entryPoints.push(entryPoint);\n  });\n\n  // now that we have the entry points, sort them alphabetically and\n  // run the traversal to get the ordered module list\n  entryPoints = entryPoints.sort();\n\n  var modules = [];\n\n  entryPoints.reverse().forEach(function(moduleName) {\n    traverseTree(tree, moduleName, function(depName, parentName) {\n      if (modules.indexOf(depName) == -1)\n        modules.push(depName);\n    }, traceOpts, true);\n  });\n\n  return {\n    entryPoints: entryPoints,\n    modules: modules.reverse()\n  };\n}\n\n// run the plugin bundle hook on the list of loads\n// returns the assetList\nexports.pluginBundleHook = pluginBundleHook;\nfunction pluginBundleHook(loader, loads, compileOpts, outputOpts) {\n  var outputs = [];\n  // plugins have the ability to report an asset list during builds\n  var assetList = [];\n  var pluginLoads = {};\n\n  // store just plugin loads\n  loads.forEach(function(load) {\n    if (load.metadata.loader) {\n      var pluginLoad = extend({}, load);\n      pluginLoad.address = loader.baseURL + load.path;\n      (pluginLoads[load.metadata.loader] = pluginLoads[load.metadata.loader] || []).push(pluginLoad);\n    }\n  });\n\n  return Promise.all(Object.keys(pluginLoads).map(function(pluginName) {\n    var loads = pluginLoads[pluginName];\n    var loaderModule = loads[0].metadata.loaderModule;\n\n    if (loaderModule.listAssets)\n      return Promise.resolve(loaderModule.listAssets.call(loader.pluginLoader, loads, compileOpts, outputOpts))\n      .then(function(_assetList) {\n        assetList = assetList.concat(_assetList.map(function(asset) {\n          return {\n            url: asset.url,\n            type: asset.type,\n            source: asset.source,\n            sourceMap: asset.sourceMap\n          };\n        }));\n      });\n  }))\n  .then(function() {\n    return Promise.all(Object.keys(pluginLoads).map(function(pluginName) {\n      var loads = pluginLoads[pluginName];\n      var loaderModule = loads[0].metadata.loaderModule;\n\n      if (compileOpts.inlinePlugins) {\n        if (loaderModule.inline) {\n          return Promise.resolve(loaderModule.inline.call(loader.pluginLoader, loads, compileOpts, outputOpts));\n        }\n        // NB deprecate bundle hook for inline hook\n        else if (loaderModule.bundle) {\n          // NB deprecate the 2 argument form\n          if (loaderModule.bundle.length < 3)\n            return Promise.resolve(loaderModule.bundle.call(loader.pluginLoader, loads, extend(extend({}, compileOpts), outputOpts)));\n          else\n            return Promise.resolve(loaderModule.bundle.call(loader.pluginLoader, loads, compileOpts, outputOpts));\n        }\n      }\n    }));\n  })\n  .then(function(compiled) {\n    var outputs = [];\n    compiled = compiled || [];\n    compiled.forEach(function(output) {\n      if (output instanceof Array)\n        outputs = outputs.concat(output);\n      else if (output)\n        outputs.push(output);\n    });\n\n    return {\n      outputs: outputs,\n      assetList: assetList\n    };\n  });\n}\n\nexports.compileTree = compileTree;\nfunction compileTree(loader, tree, traceOpts, compileOpts, outputOpts, cache) {\n\n  // verify that the tree is a tree\n  verifyTree(tree);\n\n  var ordered = getTreeModulesPostOrder(tree, traceOpts);\n\n  var inputEntryPoints;\n\n  // get entrypoints from graph algorithm\n  var entryPoints;\n\n  var modules;\n\n  var outputs = [];\n\n  var compilers = {};\n\n  return Promise.resolve()\n  .then(function() {\n    // compileOpts.entryPoints can be unnormalized\n    if (!compileOpts.entryPoints)\n      return [];\n\n    return Promise.all(compileOpts.entryPoints.map(function(entryPoint) {\n      return loader.normalize(entryPoint)\n      .then(function(normalized) {\n        return loader.getCanonicalName(normalized);\n      });\n    }))\n    .filter(function(inputEntryPoint) {\n      // skip conditional entry points and entry points not in the tree (eg rollup optimized out)\n      return !inputEntryPoint.match(/\\#\\:|\\#\\?|\\#{/) && tree[inputEntryPoint];\n    })\n  })\n  .then(function(inputEntryPoints) {\n    entryPoints = inputEntryPoints || [];\n\n    ordered.entryPoints.forEach(function(entryPoint) {\n      if (entryPoints.indexOf(entryPoint) == -1)\n        entryPoints.push(entryPoint);\n    });\n\n    modules = ordered.modules.filter(function(moduleName) {\n      var load = tree[moduleName];\n      if (load.runtimePlugin && compileOpts.static)\n        throw new TypeError('Plugin ' + load.plugin + ' does not support static builds, compiling ' + load.name + '.');\n      return load && !load.conditional && !load.runtimePlugin;\n    });\n\n    if (compileOpts.encodeNames)\n      entryPoints = entryPoints.map(function(name) {\n        return getEncoding(name, cache.encodings, loader);\n      });\n  })\n\n  // create load output objects\n  .then(function() {\n    return Promise.all(modules.map(function(name) {\n      return Promise.resolve()\n      .then(function() {\n        var load = tree[name];\n\n        if (load === true)\n          throw new TypeError(name + ' was defined via a bundle, so can only be used for subtraction or union operations.');\n\n        return compileLoad(loader, tree[name], compileOpts, cache);\n      });\n    }));\n  })\n  .then(function(compiled) {\n    outputs = outputs.concat(compiled);\n  })\n\n  // run plugin bundle hook\n  .then(function() {\n    var pluginLoads = [];\n\n    modules.forEach(function(name) {\n      var load = tree[name];\n\n      pluginLoads.push(load);\n\n      // if we used Rollup, we should still run the bundle hook for the child loads that were compacted\n      if (load.compactedLoads)\n        load.compactedLoads.forEach(function(load) {\n          pluginLoads.push(load);\n        });\n    });\n\n    return pluginBundleHook(loader, pluginLoads, compileOpts, outputOpts);\n  })\n  .then(function(pluginResults) {\n    outputs = outputs.concat(pluginResults.outputs);\n    var assetList = pluginResults.assetList;\n\n    return Promise.resolve()\n    .then(function() {\n      // if any module in the bundle is AMD, add a \"bundle\" meta to the bundle\n      // this can be deprecated if https://github.com/systemjs/builder/issues/264 lands\n      if (modules.some(function(name) {\n            return tree[name].metadata.format == 'amd';\n          }) && !compileOpts.static)\n        outputs.unshift('\"bundle\";');\n\n      // static bundle wraps with a self-executing loader\n      if (compileOpts.static)\n        return wrapSFXOutputs(loader, tree, modules, outputs, entryPoints, compileOpts, cache);\n\n      return outputs;\n    })\n    .then(function(outputs) {\n      // NB also include all aliases of all entryPoints along with entryPoints\n      return {\n        outputs: outputs,\n        entryPoints: entryPoints,\n        assetList: assetList,\n        modules: modules.reverse()\n      };\n    });\n  });\n}\n\nexports.wrapSFXOutputs = wrapSFXOutputs;\nfunction wrapSFXOutputs(loader, tree, modules, outputs, entryPoints, compileOpts, cache) {\n  var compilers = {};\n  var externalDeps = [];\n\n  Object.keys(tree).forEach(function(module) {\n    if (tree[module] === false && !loader.has(module))\n      externalDeps.push(module);\n  });\n\n  externalDeps.sort();\n\n  // determine compilers used\n  var legacyTranspiler = false;\n  modules.forEach(function(name) {\n    if (!legacyTranspiler && tree[name].metadata.originalSource)\n      legacyTranspiler = true;\n    compilers[tree[name].metadata.format] = true;\n  });\n\n  // include compiler helpers at the beginning of outputs\n  Object.keys(compilerMap).forEach(function(format) {\n    if (!compilers[format])\n      return;\n    var compiler = require(compilerMap[format]);\n    if (compiler.sfx)\n      outputs.unshift(compiler.sfx(loader));\n  });\n\n  // determine if the SFX bundle has any external dependencies it relies on\n  var globalDeps = [];\n  modules.forEach(function(name) {\n    var load = tree[name];\n\n    // check all deps are present\n    load.deps.forEach(function(dep) {\n      var key = load.depMap[dep];\n      if (!(key in tree) && !loader.has(key)) {\n        if (compileOpts.format == 'esm')\n          throw new TypeError('ESM static builds with externals only work when all modules in the build are ESM.');\n\n        if (externalDeps.indexOf(key) == -1)\n          externalDeps.push(key);\n      }\n    });\n  });\n\n  var externalDepIds = externalDeps.map(function(dep) {\n    if (compileOpts.format == 'global' ||\n        compileOpts.format == 'umd' && (compileOpts.globalName || Object.keys(compileOpts.globalDeps).length > 0)) {\n      var alias = getAlias(loader, dep);\n      var globalDep = compileOpts.globalDeps[dep] || compileOpts.globalDeps[alias];\n      if (!globalDep)\n        throw new TypeError('Global SFX bundle dependency \"' + alias +\n         '\" must be configured to an environment global via the globalDeps option.');\n\n      globalDeps.push(globalDep);\n    }\n\n    // remove external deps from calculated entry points list\n    var entryPointIndex = entryPoints.indexOf(dep);\n    if (entryPointIndex != -1)\n      entryPoints.splice(entryPointIndex, 1);\n\n    if (compileOpts.encodeNames)\n      return getEncoding(dep, cache.encodings, loader);\n    else\n      return dep;\n  });\n\n  // next wrap with the core code\n  return asp(fs.readFile)(path.resolve(__dirname, '../templates/sfx-core.min.js'))\n  .then(function(sfxcore) {\n    // for NodeJS execution to work correctly, we need to ensure the scoped module, exports and require variables are nulled out\n    outputs.unshift(\"var require = this.require, exports = this.exports, module = this.module;\");\n\n    // if the first entry point is a dynamic module, then it is exportDefault always by default\n    var exportDefault = compileOpts.exportDefault;\n    var exportedLoad = tree[compileOpts.encodeNames && getName(entryPoints[0], cache.encodings) || entryPoints[0]];\n    if (exportedLoad && exportedLoad.metadata.format != 'system' && exportedLoad.metadata.format != 'esm')\n      exportDefault = true;\n\n    outputs.unshift(sfxcore.toString(), \"(\" + JSON.stringify(entryPoints) + \", \" + JSON.stringify(externalDepIds) + \", \" +\n        (exportDefault ? \"true\" : \"false\") + \", function(\" + compileOpts.systemGlobal + \") {\");\n\n    outputs.push(\"})\");\n    return asp(fs.readFile)(path.resolve(__dirname, '../templates/sfx-' + compileOpts.format + '.js'));\n  })\n  // then include the sfx module format wrapper\n  .then(function(formatWrapper) {\n    outputs.push(template(formatWrapper.toString(), {\n      deps: externalDeps.map(function(dep) {\n        if (dep.indexOf('#:') != -1)\n          dep = dep.replace('#:/', '/');\n        var name = getAlias(loader, dep);\n        return name;\n      }),\n      globalDeps: globalDeps,\n      globalName: compileOpts.globalName\n    }));\n  })\n  // then wrap with the runtime\n  .then(function() {\n    if (!legacyTranspiler)\n      return;\n\n    // NB legacy runtime wrappings\n    var usesBabelHelpersGlobal = modules.some(function(name) {\n      return tree[name].metadata.usesBabelHelpersGlobal;\n    });\n    // regenerator runtime check\n    if (!usesBabelHelpersGlobal)\n      usesBabelHelpersGlobal = modules.some(function(name) {\n        return tree[name].metadata.format == 'esm' && cache.loads[name].output.source.match(/regeneratorRuntime/);\n      });\n    if (compileOpts.runtime && usesBabelHelpersGlobal)\n      return getModuleSource(loader, 'babel/external-helpers')\n      .then(function(source) {\n        outputs.unshift(source);\n      });\n  })\n  .then(function() {\n    if (!legacyTranspiler)\n      return;\n\n    // NB legacy runtime wrappings to eb deprecated\n    var usesTraceurRuntimeGlobal = modules.some(function(name) {\n      return tree[name].metadata.usesTraceurRuntimeGlobal;\n    });\n    if (compileOpts.runtime && usesTraceurRuntimeGlobal)\n      return getModuleSource(loader, 'traceur-runtime')\n      .then(function(source) {\n        // protect System global clobbering\n        outputs.unshift(\"(function(){ var curSystem = typeof System != 'undefined' ? System : undefined;\\n\" + source + \"\\nSystem = curSystem; })();\");\n      });\n  })\n  // for AMD, CommonJS and global SFX outputs, add a \"format \" meta to support SystemJS loading\n  .then(function() {\n    if (compileOpts.formatHint)\n      outputs.unshift(getFormatHint(compileOpts));\n  })\n  .then(function() {\n    return outputs;\n  });\n}\n\nexports.attachCompilers = function(loader) {\n  Object.keys(compilerMap).forEach(function(compiler) {\n    var attach = require(compilerMap[compiler]).attach;\n    if (attach)\n      attach(loader);\n  });\n};\n\nfunction getModuleSource(loader, module) {\n  return loader.normalize(module)\n  .then(function(normalized) {\n    return loader.locate({ name: normalized, metadata: {} });\n  })\n  .then(function(address) {\n    return loader.fetch({ address: address, metadata: {} });\n  })\n  .then(function(fetched) {\n    // allow to be a redirection module\n    var redirection = fetched.toString().match(/^\\s*module\\.exports = require\\(\\\"([^\\\"]+)\\\"\\);\\s*$/);\n    if (redirection)\n      return getModuleSource(loader, redirection[1]);\n    return fetched;\n  })\n  .catch(function(err) {\n    console.log('Unable to find helper module \"' + module + '\". Make sure it is configured in the builder.');\n    throw err;\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/lib/arithmetic.js":"var asp = require('bluebird').promisify;\nvar Promise = require('bluebird');\nvar glob = require('glob');\nvar path = require('path');\nvar url = require('url');\n\nvar getLoadDependencies = require('./trace').getLoadDependencies;\n\nvar fromFileURL = require('./utils').fromFileURL;\nvar toFileURL = require('./utils').toFileURL;\n\nvar verifyTree = require('./utils').verifyTree;\n\nfunction parseExpression(expressionString) {\n  expressionString = ' + ' + expressionString;\n\n  var index = 0;\n  var operations = [];\n  var operatorRegex = /[\\+\\-\\&]/;\n  var errorMessagesFromIndex = 3;\n\n  function getNextIdentifier() {\n    eatWhitespace();\n    var firstChar = expressionString.charAt(index);\n\n    if (operatorRegex.test(firstChar)){\n      throw 'Syntax Error: Identifier or sub expression expected after <' + expressionString.slice(errorMessagesFromIndex).substr(0, index - errorMessagesFromIndex) + '> but found <' + firstChar + '> instead';\n    }\n\n    if (firstChar === '(') {\n      var closingParenIndex = index,\n          numOpenBeforeSelf = 0;\n\n      while (++closingParenIndex < expressionString.length){\n        if (expressionString.charAt(closingParenIndex) === '('){\n          numOpenBeforeSelf++;\n        } else if (expressionString.charAt(closingParenIndex) === ')') {\n          if (numOpenBeforeSelf){\n            numOpenBeforeSelf--;\n          } else {\n            break;\n          }\n        }\n      }\n      if (expressionString.charAt(closingParenIndex) !== ')'){\n        throw 'Syntax Error: Expression <' + expressionString.substr(index) + '> is never terminated. Did you forget to add a closing \")\"?';\n      }\n\n      var wholeExpression = expressionString.substring(index + 1, closingParenIndex);\n      index = closingParenIndex + 1;\n      return { bulkOperation: wholeExpression };\n    }\n\n    var result = \"\";\n    //scan the identifier\n    for (; index < expressionString.length; index++) {\n      var currentChar = expressionString.charAt(index);\n      //can have spaces in file names - so we need whitespace, operator, whitespace.\n      if (/^\\s+[\\+\\-\\&]\\s+/.test(expressionString.substr(index))) {\n        return result;\n      } else {\n        result += currentChar;\n      }\n    }\n    return result.replace(/\\s+$/, ''); //it appears as though trailing whitespace is trimmed downstream, but I'm snipping here to be safe\n  }\n\n  function getNextOperator() {\n    eatWhitespace();\n    if (index === expressionString.length) return null;\n\n    var candidateResult = expressionString.charAt(index++); //all operators are single characters at the moment\n\n    if (!operatorRegex.test(candidateResult)){\n      throw 'Syntax Error: An operator was expected after <' + expressionString.slice(errorMessagesFromIndex).substr(0, index - 1 - errorMessagesFromIndex) + '> but found <' + expressionString.substring(index - 1) + '> instead';\n    }\n\n    return candidateResult;\n  }\n\n  function eatWhitespace() {\n    //wind past whitespace\n    for (; index < expressionString.length; index++) {\n      if (/\\S/.test(expressionString.charAt(index))) {\n        break;\n      }\n    }\n  }\n\n  var operator;\n  while (index < expressionString.length && (operator = getNextOperator())) {\n    var moduleNameOrSubExpression = getNextIdentifier();\n\n    if (typeof moduleNameOrSubExpression === 'object'){\n      operations.push({\n        operator: operator,\n        bulkOperation: moduleNameOrSubExpression.bulkOperation\n      });\n    } else {\n      // detect [moduleName] syntax for individual modules not trees\n      var singleModule = moduleNameOrSubExpression.substr(0, 1) == '[' && moduleNameOrSubExpression.substr(moduleNameOrSubExpression.length - 1, 1) == ']';\n      if (singleModule) {\n        moduleNameOrSubExpression = moduleNameOrSubExpression.substr(1, moduleNameOrSubExpression.length - 2);\n      }\n\n      var canonicalized = moduleNameOrSubExpression.substr(0, 1) == '`' && moduleNameOrSubExpression.substr(moduleNameOrSubExpression.length - 1, 1) == '`';\n      if (canonicalized) {\n        moduleNameOrSubExpression = moduleNameOrSubExpression.substr(1, moduleNameOrSubExpression.length - 2);\n      }\n\n      operations.push({\n        operator: operator,\n        moduleName: moduleNameOrSubExpression,\n        singleModule: singleModule,\n        canonicalized: canonicalized\n      });\n    }\n  }\n\n  return operations;\n}\n\nfunction getTreeOperation(symbol) {\n  if (symbol == '+')\n    return addTrees;\n  else if (symbol == '-')\n    return subtractTrees;\n  else if (symbol == '&')\n    return intersectTrees;\n  else\n    throw new TypeError('Unknown operator ' + symbol);\n}\n\nfunction getTreeModuleOperation(builder, symbol, traceOpts) {\n  if (symbol == '+')\n    return function(tree, canonical) {\n      var addedTree = {};\n      for (var p in tree)\n        addedTree[p] = tree[p];\n\n      return builder.tracer.getLoadRecord(canonical, traceOpts).then(function(load) {\n        addedTree[canonical] = load;\n        return addedTree;\n      });\n    };\n  else if (symbol == '-')\n    return function(tree, canonical) {\n      var subtractedTree = {};\n      for (var p in tree) {\n        if (p != canonical)\n          subtractedTree[p] = tree[p];\n      }\n      return subtractedTree;\n    };\n  else if (symbol == '&')\n    throw new TypeError('Single modules cannot be intersected.');\n  else\n    throw new TypeError('Unknown operator ' + symbol);\n}\n\nfunction expandGlobAndCanonicalize(builder, operation) {\n  var loader = builder.loader;\n\n  // no glob -> just canonicalize\n  if (operation.moduleName.indexOf('*') == -1) {\n    if (operation.canonicalized)\n      return [operation];\n\n    return loader.normalize(operation.moduleName)\n    .then(function(normalized) {\n      operation.moduleName = builder.getCanonicalName(normalized);\n      return [operation];\n    });\n  }\n\n  // globbing\n  var metadata = {};\n  var globSuffix = operation.moduleName[operation.moduleName.length - 1] == '*';\n  var pluginSyntax = operation.moduleName.indexOf('!') != -1;\n\n  return Promise.resolve()\n  .then(function() {\n    if (operation.canonicalized) {\n      return loader.decanonicalize(operation.moduleName);\n    }\n    else {\n      // normalizeSync avoids package config loading which we don't want for wildcards\n      return loader.normalizeSync(operation.moduleName);\n    }\n  })\n  .then(function(normalized) {\n    // remove ALL extension adding when globbing\n    if (globSuffix && !operation.canonicalized) {\n      var extIndex = normalized.lastIndexOf('.');\n      if (extIndex != -1 && normalized[extIndex - 1] == '*')\n        normalized = normalized.substr(0, extIndex);\n    }\n\n    return loader.locate({ name: normalized, metadata: metadata });\n  })\n  .then(function(address) {\n    // now we have a file path to glob -> glob the pattern\n    return asp(glob)(fromFileURL(address), {\n      nobrace: true,\n      noext: true,\n      nodir: true\n    });\n  })\n  .then(function(addresses) {\n    return (metadata.loader && pluginSyntax ? loader.normalize(metadata.loader) : Promise.resolve())\n    .then(function(loaderSyntaxName) {\n      return addresses.map(function(file) {\n        return {\n          operator: operation.operator,\n          moduleName: builder.getCanonicalName(toFileURL(file) + (loaderSyntaxName ? '!' + loader.getCanonicalName(loaderSyntaxName) : '')),\n          singleModule: operation.singleModule\n        };\n      });\n    });\n  });\n}\n\nexports.traceExpression = function(builder, expression, traceOpts) {\n  if (!expression)\n    throw new Error('A module expression must be provided to trace.');\n\n  if (expression instanceof Array) {\n    var tree = {};\n    return Promise.all(expression.map(function(moduleName) {\n      return builder.loader.normalize(moduleName)\n      .then(function(normalized) {\n        var canonical = builder.getCanonicalName(normalized);\n        return builder.tracer.getLoadRecord(canonical, traceOpts)\n        .then(function(load) {\n          tree[canonical] = load;\n        });\n      });\n    }))\n    .then(function() {\n      return tree;\n    });\n  }\n\n  return Promise\n    .resolve(expandAndCanonicalizeExpression(builder, expression))\n    .then(function processExpandedOperations(expandedOperations) {\n      // chain the operations, applying them with the trace of the next module\n      return expandedOperations.reduce(function(p, op) {\n        return p.then(function(curTree) {\n          // tree . module\n          if (op.singleModule)\n            return getTreeModuleOperation(builder, op.operator, traceOpts)(curTree, op.moduleName);\n\n          if (op.operationsTree){\n            return processExpandedOperations(op.operationsTree).then(function(expandedTree){\n              return getTreeOperation(op.operator)(curTree, expandedTree);\n            });\n          }\n          // tree . tree\n          return builder.tracer.traceCanonical(op.moduleName, traceOpts)\n          .then(function(nextTrace) {\n            return getTreeOperation(op.operator)(curTree, nextTrace.tree);\n          });\n        });\n      }, Promise.resolve({}));\n  });\n};\n\nfunction expandAndCanonicalizeExpression(builder, expression) {\n  var operations = parseExpression(expression);\n  var expandPromise = Promise.resolve(1);\n  var expandedOperations = [];\n\n  operations.forEach(function(operation){\n    if (operation.bulkOperation) {\n      var expandedTreePromise = expandAndCanonicalizeExpression(builder, operation.bulkOperation);\n      expandPromise = expandPromise.then(function() {\n        return Promise.resolve(expandedTreePromise)\n              .then(function(expressionsOperations){\n                expandedOperations = expandedOperations.concat({ operator: operation.operator, operationsTree: expressionsOperations });\n              });\n      });\n    } else {\n      expandPromise = expandPromise.then(function() {\n        return Promise.resolve(expandGlobAndCanonicalize(builder, operation))\n               .then(function (expanded) {\n                 expandedOperations = expandedOperations.concat(expanded);\n               });\n      })\n    }\n  });\n\n  return Promise.resolve(expandPromise).then(function(){ return expandedOperations; });\n}\n\n// returns a new tree containing tree1 n tree2\nexports.intersectTrees = intersectTrees;\nfunction intersectTrees(tree1, tree2) {\n  verifyTree(tree1);\n  verifyTree(tree2);\n\n  var name;\n  var intersectTree = {};\n\n  var tree1Names = [];\n  for (name in tree1)\n    tree1Names.push(name);\n\n  for (name in tree2) {\n    if (tree1Names.indexOf(name) == -1)\n      continue;\n    // intersect deps layer (load: false) and actual bundle includes separately\n    if (tree1[name] === false && tree2[name] === false)\n      continue;\n\n    intersectTree[name] = tree1[name] || tree2[name];\n  }\n\n  return intersectTree;\n}\n\n// returns a new tree containing tree1 + tree2\nexports.addTrees = addTrees;\nfunction addTrees(tree1, tree2) {\n  verifyTree(tree1);\n  verifyTree(tree2);\n\n  var name;\n  var unionTree = {};\n\n  for (name in tree2)\n    unionTree[name] = tree2[name];\n\n  for (name in tree1)\n    if (!(name in unionTree))\n      unionTree[name] = tree1[name];\n\n  return unionTree;\n}\n\n// returns a new tree containing tree1 - tree2\nexports.subtractTrees = subtractTrees;\nfunction subtractTrees(tree1, tree2) {\n  verifyTree(tree1);\n  verifyTree(tree2);\n\n  var name;\n  var subtractTree = {};\n\n  for (name in tree1)\n    subtractTree[name] = tree1[name];\n\n  for (name in tree2) {\n    if (tree2[name] !== false)\n      delete subtractTree[name];\n  }\n\n  return subtractTree;\n}\n\n// pre-order tree traversal with a visitor and stop condition\nexports.traverseTree = traverseTree;\nfunction traverseTree(tree, moduleName, visitor, traceOpts, reversePost, parent, seen) {\n  if (!seen) {\n    // NB traceOpts.conditions should be strictly canonicalized on the first run\n    traceOpts = traceOpts || {};\n    verifyTree(tree);\n  }\n\n  seen = seen || [];\n  seen.push(moduleName);\n  parent = parent || null;\n\n  var curNode = tree[moduleName];\n\n  if (curNode && visitor(moduleName, parent) !== false) {\n    var deps = getLoadDependencies(curNode, traceOpts, traceOpts.conditions, traceOpts.inlineConditions);\n    if (reversePost)\n      deps = deps.reverse();\n    deps.forEach(function(dep) {\n      if (seen.indexOf(dep) == -1)\n        traverseTree(tree, dep, visitor, traceOpts, reversePost, moduleName, seen);\n    });\n  }\n}","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/lib/trace.js":"var getCanonicalName = require('./utils').getCanonicalName;\nvar glob = require('glob');\nvar toFileURL = require('./utils').toFileURL;\nvar fromFileURL = require('./utils').fromFileURL;\nvar asp = require('bluebird').promisify;\nvar fs = require('fs');\nvar path = require('path');\nvar extend = require('./utils').extend;\nvar Promise = require('bluebird');\nvar getPackage = require('./utils').getPackage;\nvar getPackageConfigPath = require('./utils').getPackageConfigPath;\nvar isPackageConfig = require('./utils').isPackageConfig;\nvar parseCondition = require('./utils').parseCondition;\nvar serializeCondition = require('./utils').serializeCondition;\nvar dataUriToBuffer = require('data-uri-to-buffer');\n\nmodule.exports = Trace;\n\nfunction Trace(loader, traceCache) {\n  // when creating a new trace, we by default invalidate the freshness of the trace cache\n  Object.keys(traceCache).forEach(function(canonical) {\n    var load = traceCache[canonical];\n\n    if (load && !load.conditional)\n      load.fresh = false;\n  });\n\n\n  this.loader = loader;\n  // stored traced load records\n  this.loads = traceCache || {};\n  // in progress traces\n  this.tracing = {};\n}\n\n/*\n * High-level functions\n */\nvar namedRegisterRegEx = /(System\\.register(Dynamic)?|define)\\(('[^']+'|\"[^\"]+\")/g;\nTrace.prototype.traceModule = function(moduleName, traceOpts) {\n  var loader = this.loader;\n\n  return Promise.resolve(loader.normalize(moduleName))\n  .then(function(normalized) {\n    return traceCanonical(getCanonicalName(loader, normalized), traceOpts);\n  });\n};\n\n// given a module, return the conditional environment variation space\nTrace.getConditionalEnv = function(builder, loads, traceOpts) {\n  var conditionalEnvVariations = {};\n\n  Object.keys(loads).forEach(function(canonical) {\n    var load = loads[canonical];\n    if (!load.conditional)\n      return;\n\n    var envVariations = Trace.getConditionalResolutions(load.conditional, traceOpts.conditions, traceOpts.inlineConditions).conditionalEnvVariations;\n\n    Object.keys(envVariations).forEach(function(condition) {\n      if (envVariations[condition] instanceof Array) {\n        conditionalEnvVariations[condition] = conditionalEnvVariations[condition] || [];\n        envVariations[condition].forEach(function(conditionValue) {\n          if (conditionalEnvVariations[condition].indexOf(conditionValue) === -1)\n            conditionalEnvVariations[condition].push(conditionValue);\n        });\n      }\n      else {\n        conditionalEnvVariations[condition] = conditionalEnvVariations[condition] || envVariations[condition];\n      }\n    });\n  });\n  return conditionalEnvVariations;\n};\n\nTrace.prototype.traceCanonical = function(canonical, traceOpts) {\n  var self = this;\n\n  return self.getAllLoadRecords(canonical, traceOpts, traceOpts.conditions, traceOpts.inlineConditions, {}, [])\n  .then(function(loads) {\n    // if it is a bundle, we just use a regex to extract the list of loads\n    // as \"true\" records for subtraction arithmetic use only\n    var thisLoad = loads[canonical];\n\n    if (thisLoad && !thisLoad.conditional && thisLoad.metadata.bundle) {\n      namedRegisterRegEx.lastIndex = 0;\n      var curMatch;\n      while ((curMatch = namedRegisterRegEx.exec(thisLoad.source)))\n        loads[curMatch[3].substr(1, curMatch[3].length - 2)] = true;\n    }\n\n    return {\n      moduleName: canonical,\n      tree: loads\n    };\n  });\n}\n\nfunction isLoadFresh(load, loader, loads) {\n  if (load === undefined)\n    return false;\n\n  if (load === false)\n    return true;\n\n  if (load.configHash != loader.configHash)\n    return false;\n\n  if (load.fresh)\n    return true;\n\n  if (load.conditional)\n    return false;\n\n  if (load.plugin) {\n    if (!loader.pluginLoader.has(loader.pluginLoader.decanonicalize(load.plugin)))\n      return false;\n  }\n\n  // stat to check freshness\n  try {\n    var timestamp = fs.statSync(path.resolve(fromFileURL(loader.baseURL), load.path)).mtime.getTime();\n  }\n  catch(e) {}\n  return load.fresh = timestamp == load.timestamp;\n}\n\n/*\n * Low-level functions\n */\n// runs the pipeline hooks, returning the load record for a module\nTrace.prototype.getLoadRecord = function(canonical, traceOpts, parentStack) {\n  var loader = this.loader;\n  var loads = this.loads;\n\n  if (isLoadFresh(loads[canonical], loader, loads))\n    return Promise.resolve(loads[canonical]);\n\n  if (this.tracing[canonical])\n    return this.tracing[canonical];\n\n  var self = this;\n  var isPackageConditional = canonical.indexOf('/#:') != -1;\n\n  var curMap = loader.map;\n  loader.map = {};\n  var normalized = loader.decanonicalize(canonical);\n  loader.map = curMap;\n\n  return this.tracing[canonical] = Promise.resolve(normalized)\n  .then(function(normalized) {\n    // modules already set in the registry are system modules\n    if (loader.has(normalized))\n      return false;\n\n    // package conditional fallback normalization\n    if (!isPackageConditional)\n      normalized = normalized.replace('/#:', '/');\n\n    // -- conditional load record creation: sourceless intermediate load record --\n\n    // boolean conditional\n    var booleanIndex = canonical.lastIndexOf('#?');\n    if (booleanIndex != -1) {\n      var condition = canonical.substr(booleanIndex + 2);\n      if (condition.indexOf('|') == -1)\n        condition += '|default';\n      return {\n        name: canonical,\n        fresh: true,\n        conditional: {\n          condition: condition,\n          branch: canonical.substr(0, booleanIndex)\n        }\n      };\n    }\n\n    // package environment conditional\n    var pkgEnvIndex = canonical.indexOf('/#:');\n    if (pkgEnvIndex != -1) {\n      // NB handle a package plugin load here too\n      if (canonical.indexOf('!') != -1)\n        throw new Error('Unable to trace ' + canonical + ' - building package environment mappings of plugins is not currently supported.');\n\n      var pkgName = canonical.substr(0, pkgEnvIndex);\n      var subPath = canonical.substr(pkgEnvIndex + 3);\n\n      var normalizedPkgName = loader.decanonicalize(pkgName);\n\n      // record package config paths\n      var loadPackageConfig;\n      var packageConfigPath = getPackageConfigPath(loader.packageConfigPaths, normalizedPkgName);\n      if (packageConfigPath) {\n        loadPackageConfig = getCanonicalName(loader, packageConfigPath);\n        (loader.meta[packageConfigPath] = loader.meta[packageConfigPath] || {}).format = 'json';\n      }\n\n      // effective analog of the same function in SystemJS packages.js\n      // to work out the path with defaultExtension added.\n      // we cheat here and use normalizeSync to apply the right checks, while\n      // skipping any map entry by temporarily removing it.\n      var absURLRegEx = /^[^\\/]+:\\/\\//;\n      function isPlain(name) {\n        return name[0] != '.' && name[0] != '/' && !name.match(absURLRegEx);\n      }\n      function getMapMatch(map, name) {\n        var bestMatch, bestMatchLength = 0;\n\n        for (var p in map) {\n          if (name.substr(0, p.length) == p && (name.length == p.length || name[p.length] == '/')) {\n            var curMatchLength = p.split('/').length;\n            if (curMatchLength <= bestMatchLength)\n              continue;\n            bestMatch = p;\n            bestMatchLength = curMatchLength;\n          }\n        }\n\n        return bestMatch;\n      }\n      function toPackagePath(subPath, isFallback) {\n        if (isPlain(subPath)) {\n          // plain name -> apply map\n          if (!isFallback)\n            return loader.normalize(subPath, normalizedPkgName + '/');\n          // if a fallback conditional map, only do global map, not package map\n          else\n            return loader.normalize(subPath);\n        }\n        else if (subPath == '.') {\n          return Promise.resolve(normalizedPkgName);\n        }\n        else if (subPath.substr(0, 2) == './') {\n          var pkgMap = pkg.map;\n          pkg.map = {};\n          var normalized = loader.normalizeSync(pkgName + '/' + subPath.substr(2));\n          pkg.map = pkgMap;\n          return Promise.resolve(normalized);\n        }\n        else {\n          return Promise.resolve(normalized);\n        }\n      }\n\n      var pkg\n      var envMap;\n      var metadata = {};\n\n      // ensure we have loaded any package config first\n      // NB this does not properly deal with package config file invalidation\n      // we should handle some kind of invalidation process where a package config file change\n      // must invalidate all load records as we can't know the scope of the normalization changes\n      return loader.normalize(normalizedPkgName)\n      .then(function() {\n        pkg = loader.packages[normalizedPkgName];\n\n        var mapMatch = getMapMatch(pkg.map, subPath);\n        envMap = pkg.map[mapMatch];\n\n        if (!envMap)\n          throw new Error('Package conditional ' + canonical + ' has no package conditional map present.');\n\n        // resolve the fallback\n        return toPackagePath(subPath, true);\n      })\n      .then(function(resolvedPath) {\n        // if the fallback is itself a conditional then use that directly\n        if (resolvedPath.match(/\\#[\\:\\?\\{]/))\n          return getCanonicalName(loader, resolvedPath);\n\n        // if the fallback is a system module then that is it\n        if (isPlain(resolvedPath))\n          return resolvedPath;\n\n        return loader.locate({ name: resolvedPath, metadata: metadata })\n        .then(function(address) {\n          // allow build: false trace opt-out\n          if (metadata.build === false)\n            return false;\n\n          // check if the fallback exists\n          return new Promise(function(resolve) {\n            fs.exists(fromFileURL(address), resolve);\n          })\n          .then(function(fallbackExists) {\n            if (fallbackExists)\n              return getCanonicalName(loader, resolvedPath);\n          });\n        });\n      })\n      .then(function(fallback) {\n        // environment trace\n        return Promise.all(Object.keys(envMap).map(function(envCondition) {\n          var mapping = envMap[envCondition];\n          var conditionObj = parseCondition(envCondition);\n\n          return loader.normalize(conditionObj.module, normalizedPkgName)\n          .then(function(conditionModule) {\n            conditionObj.module = getCanonicalName(loader, conditionModule);\n            return toPackagePath(mapping, false);\n          })\n          .then(function(normalizedMapping) {\n            return {\n              condition: serializeCondition(conditionObj),\n              branch: getCanonicalName(loader, normalizedMapping)\n            };\n          });\n        }))\n        .then(function(envs) {\n          return {\n            name: canonical,\n            fresh: true,\n            packageConfig: loadPackageConfig,\n            conditional: {\n              envs: envs,\n              fallback: fallback\n            }\n          };\n        });\n      });\n    }\n\n    // conditional interpolation\n    var interpolationRegEx = /#\\{[^\\}]+\\}/;\n    var interpolationMatch = canonical.match(interpolationRegEx);\n    if (interpolationMatch) {\n      var condition = interpolationMatch[0].substr(2, interpolationMatch[0].length - 3);\n\n      if (condition.indexOf('|') == -1)\n        condition += '|default';\n\n      var metadata = {};\n      return Promise.resolve(loader.locate({ name: normalized.replace(interpolationRegEx, '*'), metadata: metadata }))\n      .then(function(address) {\n        if (address.substr(0, 8) != 'file:///' && !load.metadata.loader)\n          metadata.build = false;\n\n        // allow build: false trace opt-out\n        if (metadata.build === false)\n          return false;\n\n        // glob the conditional interpolation variations from the filesystem\n        var globIndex = address.indexOf('*');\n        return asp(glob)(fromFileURL(address), { dot: true, nobrace: true, noglobstar: true, noext: true, nodir: true })\n        .then(function(paths) {\n          var branches = {};\n          paths.forEach(function(path) {\n            path = toFileURL(path);\n\n            var pathCanonical = getCanonicalName(loader, path);\n            var interpolate = pathCanonical.substr(interpolationMatch.index, path.length - address.length + 1);\n\n            if (normalized.indexOf('!') != -1) {\n              if (loader.pluginFirst)\n                pathCanonical = getCanonicalName(loader, metadata.loader) + '!' + pathCanonical;\n              else\n                pathCanonical = pathCanonical + '!' + getCanonicalName(loader, metadata.loader);\n            }\n            branches[interpolate] = pathCanonical;\n          });\n\n          // if the condition values have been provided via traceOpts.conditions\n          // then add these to the glob variations as well\n          if (traceOpts.conditions[condition])\n            traceOpts.conditions[condition].forEach(function(c) {\n              if (branches[c])\n                return;\n              var branchCanonical = canonical.substr(0, interpolationMatch.index) + c + canonical.substr(interpolationMatch[0].length + interpolationMatch.index);\n              branches[c] = branchCanonical;\n            });\n\n          return {\n            name: canonical,\n            fresh: false, // we never cache conditional interpolates and always reglob\n            conditional: {\n              condition: condition,\n              branches: branches\n            }\n          };\n        });\n      });\n    }\n\n    // -- trace loader hooks --\n    var load = {\n      name: canonical,\n      // baseURL-relative path to address\n      path: null,\n      metadata: {},\n      deps: [],\n      depMap: {},\n      source: null,\n\n      // this is falsified by builder.reset to indicate we should restat\n      fresh: true,\n      // timestamp from statting the underlying file source at path\n      timestamp: null,\n      // each load stores a hash of the configuration from the time of trace\n      // configHash is set by the loader.config function of the builder\n      configHash: loader.configHash,\n\n      plugin: null,\n      runtimePlugin: false,\n\n      // plugins via syntax must build in the plugin package config\n      pluginConfig: null,\n\n      // packages have a config file that must be built in for bundles\n      packageConfig: null,\n      isPackageConfig: isPackageConfig(loader, canonical),\n\n      // these are only populated by the separate builder.getDeferredImports(tree) method\n      deferredImports: null,\n\n      // in the case of Rollup, a single load can represent several compacted loads\n      compactedLoads: null,\n    };\n    var curHook = 'locate';\n    var originalSource;\n    return Promise.resolve(loader.locate({ name: normalized, metadata: load.metadata}))\n    .then(function(address) {\n      curHook = '';\n\n      if (address.substr(0, 8) != 'file:///' && !load.metadata.loader)\n        load.metadata.build = false;\n\n      // build: false build config - null load record\n      if (load.metadata.build === false)\n        return false;\n\n      if (address.substr(0, 8) == 'file:///')\n        load.path = path.relative(fromFileURL(loader.baseURL), fromFileURL(address));\n\n      return Promise.resolve()\n      .then(function() {\n        // set load.plugin to canonical plugin name if a plugin load\n        if (load.metadata.loaderModule)\n          return Promise.resolve(loader.pluginLoader.normalize(load.metadata.loader, normalized))\n          .then(function(pluginNormalized) {\n            load.plugin = getCanonicalName(loader, pluginNormalized);\n\n            if (load.metadata.loaderModule &&\n                (load.metadata.loaderModule.build === false || Object.keys(load.metadata.loaderModule).length == 0 ||\n                (typeof load.metadata.loaderModule === 'function' || load.metadata.loaderModule.toString && load.metadata.loaderModule.toString() === 'Module' && typeof load.metadata.loaderModule.default === 'function')))\n              load.runtimePlugin = true;\n\n            if (pluginNormalized.indexOf('!') == -1 && !load.runtimePlugin && getPackage(loader.packages, pluginNormalized)) {\n              var packageConfigPath = getPackageConfigPath(loader.packageConfigPaths, pluginNormalized);\n              if (packageConfigPath) {\n                load.pluginConfig = getCanonicalName(loader, packageConfigPath);\n                (loader.meta[packageConfigPath] = loader.meta[packageConfigPath] || {}).format = 'json';\n              }\n            }\n          });\n      })\n      .then(function() {\n        if (load.runtimePlugin)\n          return load;\n\n        curHook = 'fetch';\n\n\n        return loader\n          .fetch({ name: normalized, metadata: load.metadata, address: address })\n\n          // Parse source map definitions inside of the source and apply it to the metadata if present.\n          .then(function (source) {\n            if (!traceOpts.sourceMaps || load.metadata.sourceMap)\n              return source;\n\n            // Search for the specified sourceMap definition in the files source.\n            var sourceMap = source.match(/^\\s*\\/\\/\\s*[#@] sourceMappingURL=([^\\s'\"]*)/m);\n\n            if (!sourceMap)\n              return source;\n\n            // Once the sourceMappingURL starts with `data:`, we have to parse it as an inline source map.\n            if (sourceMap[1].startsWith('data:')) {\n              load.metadata.sourceMap = JSON.parse(dataUriToBuffer(sourceMap[1]).toString('utf8'));\n              return source;\n            } else {\n              // Retrieve the path of the sourceMappingURL in relative to the\n              // relative path to the .map file\n              var sourceMapPath = path.join(path.dirname(fromFileURL(address)), sourceMap[1]);\n\n              return asp(fs.readFile)(sourceMapPath, 'utf8').then(function (sourceMap) {\n                load.metadata.sourceMap = JSON.parse(sourceMap);\n                return source;\n              })\n              // dont let a missing source map fail the entire build\n              .catch(function() {\n                return source;\n              });\n            }\n          })\n\n        .then(function(source) {\n          if (typeof source != 'string')\n            throw new TypeError('Loader fetch hook did not return a source string');\n          originalSource = source;\n          curHook = 'translate';\n\n          // default loader fetch hook will set load.metadata.timestamp\n          if (load.metadata.timestamp) {\n            load.timestamp = load.metadata.timestamp;\n            load.metadata.timestamp = undefined;\n          }\n\n          return loader.translate({ name: normalized, metadata: load.metadata, address: address, source: source }, traceOpts);\n        })\n        .then(function(source) {\n\n          load.source = source;\n          curHook = 'dependency parsing';\n\n          return loader.instantiate({ name: normalized, metadata: load.metadata, address: address, source: source });\n        })\n        .then(function(result) {\n\n          // allow late build opt-out\n          if (load.metadata.build === false)\n            return;\n\n          curHook = '';\n          if (!result)\n            throw new TypeError('Native ES Module builds not supported. Ensure transpilation is included in the loader pipeline.');\n\n          load.deps = result.deps;\n\n          // legacy es module transpilation translates to get the dependencies, so we need to revert for re-compilation\n          if (load.metadata.format == 'esm' && load.metadata.originalSource)\n            load.source = originalSource;\n\n          // record package config paths\n          if (getPackage(loader.packages, normalized) && !load.isPackageConfig) {\n            var packageConfigPath = getPackageConfigPath(loader.packageConfigPaths, normalized);\n            if (packageConfigPath) {\n              load.packageConfig = getCanonicalName(loader, packageConfigPath);\n              (loader.meta[packageConfigPath] = loader.meta[packageConfigPath] || {}).format = 'json';\n            }\n          }\n\n          // normalize dependencies to populate depMap\n          return Promise.all(result.deps.map(function(dep) {\n            return loader.normalize(dep, normalized, address)\n            .then(function(normalized) {\n              try {\n                load.depMap[dep] = getCanonicalName(loader, normalized);\n              }\n              catch(e) {\n                if (!traceOpts.excludeURLs || normalized.substr(0, 7) == 'file://')\n                  throw e;\n                load.depMap[dep] = normalized;\n              }\n            });\n          }));\n        });\n      })\n      .catch(function(err) {\n        var msg = (curHook ? ('Error on ' + curHook + ' for ') : 'Error tracing ') + canonical + ' at ' + normalized;\n\n        if (parentStack)\n          parentStack.reverse().forEach(function(parent) {\n            msg += '\\n\\tLoading ' + parent;\n          });\n\n        // rethrow loader hook errors with the hook information\n        var newMsg = msg + '\\n\\t' + (err.message || err);\n        var newErr = new Error(newMsg, err.fileName, err.lineNumber);\n        newErr.originalErr = err.originalErr || err;\n        newErr.stack = msg + '\\n\\t' + (err.stack || err);\n        throw newErr;\n      })\n      .then(function() {\n        // format: 'system' as primary detector\n        if (load.metadata.format === 'register')\n          load.metadata.format = 'system';\n\n        // remove unnecessary metadata for trace\n        load.metadata.entry = undefined;\n        load.metadata.builderExecute = undefined;\n        load.metadata.parseTree = undefined;\n        load.metadata.ast = undefined;\n\n        if (load.metadata.build === false)\n          return false;\n\n        return load;\n      });\n    });\n  })\n  .then(function(load) {\n    self.tracing[canonical] = undefined;\n    return loads[canonical] = load;\n  }).catch(function(err) {\n    self.tracing[canonical] = undefined;\n    throw err;\n  });\n};\n\n/*\n * Returns the full trace tree of a module\n *\n * - conditionalEnv represents the conditional tracing environment module values to impose on the trace\n * -\n *\n * conditionalEnv provides canonical condition tracing rules of the form:\n *\n *  {\n *    'some/interpolation|value': true, // include ALL variations\n *    'another/interpolation|value': false, // include NONE\n *    'custom/interpolation|value': ['specific', 'values']\n *\n *    // default BOOLEAN entry::\n *    '@system-env|browser': false,\n *    '@system-env|~browser': false\n *\n *    // custom boolean entry\n *    // boolean only checks weak truthiness to allow overlaps\n *    '@system-env|~node': true\n *  }\n *\n */\nvar systemModules = ['@empty', '@system-env', '@@cjs-helpers', '@@global-helpers'];\nTrace.prototype.getAllLoadRecords = function(canonical, traceOpts, canonicalConditionalEnv, canonicalInlineConditionals, curLoads, parentStack) {\n  var loader = this.loader;\n\n  curLoads = curLoads || {};\n\n  if (canonical in curLoads)\n    return curLoads;\n\n  var self = this;\n  return this.getLoadRecord(canonical, traceOpts, parentStack)\n  .then(function(load) {\n\n    // check this again – might have been loaded asynchronously since the last check\n    if (canonical in curLoads)\n      return curLoads;\n\n    // conditionals, build: false and system modules are falsy loads in the trace trees\n    // (that is, part of depcache, but not built)\n    // we skip system modules though\n    if (systemModules.indexOf(canonical) == -1)\n      curLoads[canonical] = load;\n\n    if (load) {\n      parentStack = parentStack.concat([canonical]);\n      return Promise.all(Trace.getLoadDependencies(load, traceOpts, canonicalConditionalEnv, canonicalInlineConditionals).map(function(dep) {\n        return self.getAllLoadRecords(dep, traceOpts, canonicalConditionalEnv, canonicalInlineConditionals, curLoads, parentStack);\n      }));\n    }\n  })\n  .then(function() {\n    return curLoads;\n  });\n};\n\nfunction conditionalComplement(condition) {\n  var conditionObj = parseCondition(condition);\n  conditionObj.negate = !conditionObj.negate;\n  return serializeCondition(conditionObj);\n}\n\nTrace.toCanonicalConditionalEnv = toCanonicalConditionalEnv;\nfunction toCanonicalConditionalEnv(loader, conditionalEnv) {\n  var canonicalConditionalEnv = {};\n\n  // convert boolean conditions of the form\n  // @system-env|browser: [true, false]\n  // @system-env|~browser: true\n  // into just:\n  // @system-env|browser: [true, false]\n  // to be deprecated in due course\n  Object.keys(conditionalEnv).map(function(m) {\n    var conditionObj = parseCondition(m);\n\n    if (!(conditionalEnv[m] instanceof Array)) {\n      if (!conditionObj.negate) {\n        conditionalEnv[m] = [conditionalEnv[m]];\n      }\n      else {\n        var complement = conditionalComplement(m);\n        if (conditionalEnv[complement]) {\n          if (conditionalEnv[complement] instanceof Array) {\n            if (conditionalEnv[complement].indexOf(!conditionalEnv[m]) === -1)\n              conditionalEnv[complement].push(!conditionalEnv[m]);\n          }\n          else {\n            if (!conditionalEnv[m] !== conditionalEnv[complement])\n              conditionalEnv[conditionalComplement(m)] = [conditionalEnv[conditionalComplement(m)], !conditionalEnv[m]];\n          }\n        }\n        else {\n          conditionalEnv[conditionalComplement(m)] = [!conditionalEnv[m]];\n        }\n        delete conditionalEnv[m];\n      }\n    }\n  });\n\n  return Promise.all(Object.keys(conditionalEnv).map(function(m) {\n    var conditionObj = parseCondition(m);\n    return loader.normalize(conditionObj.module)\n    .then(function(normalized) {\n      conditionObj.module = getCanonicalName(loader, normalized);\n      var canonicalCondition = serializeCondition(conditionObj);\n      canonicalConditionalEnv[canonicalCondition] = conditionalEnv[m];\n    });\n  }))\n  .then(function() {\n    return canonicalConditionalEnv;\n  });\n}\n\n/*\n * to support static conditional builds, we use the conditional tracing options\n * to inline resolved conditions for the trace\n * basically rewriting the tree without any conditionals\n * where conditions are still present or conflicting we throw an error\n */\nTrace.prototype.inlineConditions = function(tree, loader, traceOpts) {\n  var self = this;\n\n  var inconsistencyErrorMsg = 'For static condition inlining only an exact environment resolution can be built, pending https://github.com/systemjs/builder/issues/311.';\n\n  // ensure we have no condition conflicts\n  for (var c in traceOpts.inlineConditions) {\n    if (traceOpts.inlineConditions[c].length > 1)\n      throw new TypeError('Error building condition ' + c + '. ' + inconsistencyErrorMsg);\n  }\n\n  var conditionalResolutions = {};\n  var importsSystemEnv = false;\n\n  // get the list of all conditional dependencies in the tree\n  var allConditionals = [];\n  Object.keys(tree).forEach(function(m) {\n    if (m.match(/#[\\:\\?\\{]/) && allConditionals.indexOf(m) === -1)\n      allConditionals.push(m);\n\n    if (!tree[m] || tree[m].conditional)\n      return;\n\n    Object.keys(tree[m].depMap).forEach(function(d) {\n      var dep = tree[m].depMap[d];\n\n      if (dep.match(/#[\\:\\?\\{]/) && allConditionals.indexOf(dep) === -1)\n        allConditionals.push(dep);\n    });\n  });\n\n  // determine the conditional resolutions\n  return Promise.all(allConditionals.map(function(c) {\n    return self.getLoadRecord(c, traceOpts)\n    .then(function(load) {\n      var branches = Trace.getConditionalResolutions(load.conditional, traceOpts.conditions, traceOpts.inlineConditions).branches;\n\n      if (branches.length === 1)\n        conditionalResolutions[c] = branches[0];\n    });\n  }))\n  .then(function() {\n    // resolve any chained conditionals\n    Object.keys(conditionalResolutions).forEach(function(c) {\n      var resolution = conditionalResolutions[c];\n\n      var seen = [];\n      while (conditionalResolutions[resolution] && seen.indexOf(resolution) == -1) {\n        seen.push(resolution);\n        resolution = conditionalResolutions[resolution];\n        conditionalResolutions[c] = resolution;\n      }\n      if (seen.indexOf(resolution) != -1)\n        throw new Error('Circular conditional resolution ' + seen.join(' -> ') + ' -> ' + resolution);\n    });\n\n    // finally we do a deep clone of the tree, applying the conditional resolutions as we go\n    // if we have a dependency on a condition not in the tree, we throw as it would be an unresolved external\n    var inlinedTree = {};\n    Object.keys(tree).forEach(function(m) {\n      var load = tree[m];\n\n      if (typeof load == 'boolean') {\n        inlinedTree[m] = load;\n        return;\n      }\n\n      if (load.conditional)\n        return;\n\n      var clonedLoad = extend({}, load);\n      clonedLoad.depMap = {};\n      Object.keys(load.depMap).forEach(function(d) {\n        var normalizedDep = load.depMap[d];\n\n        normalizedDep = conditionalResolutions[normalizedDep] || normalizedDep;\n\n        if (normalizedDep == '@system-env')\n          importsSystemEnv = true;\n\n        clonedLoad.depMap[d] = normalizedDep;\n      });\n\n      inlinedTree[m] = clonedLoad;\n    });\n\n    // if we explicitly import from the system environment, then we need to build it into a static build\n    // this is normally excluded as it is a system module in SystemJS but won't be available in static\n    // builds which is exactly what this function acts on\n    if (importsSystemEnv) {\n      inlinedTree['@system-env'] = {\n        name: '@system-env',\n        path: null,\n        metadata: {\n          format: 'json'\n        },\n        deps: [],\n        depMap: {},\n        source: JSON.stringify({\n          production: traceOpts.inlineConditions['@system-env|production'],\n          browser: traceOpts.inlineConditions['@system-env|browser'],\n          node: traceOpts.inlineConditions['@system-env|node'],\n          dev: traceOpts.inlineConditions['@system-env|dev'],\n          default: true\n        }),\n        fresh: true,\n        timestamp: null,\n        configHash: loader.configHash,\n      };\n    }\n\n    return inlinedTree;\n  });\n};\n\n/*\n * Given a conditional load record, a conditional environment, and an inline conditional environment\n * returns the list of possible conditional branch outcomes, the condition modules necessary\n * in runtime to determine non-inlined conditions and the conditionalEnvVariations\n * object representing the resultant condition space\n */\nTrace.getConditionalResolutions = function(conditional, conditionalEnv, inlineConditionals) {\n  // flatten all conditions into a filtered array of condition, module branches\n  var branches = [];\n  var conditionModules = [];\n  var conditionalEnvVariations = {};\n\n  function traceCondition(condition, value) {\n    var conditionModule = parseCondition(condition).module;\n\n    if (inlineConditionals[condition])\n      return inlineConditionals[condition][0] === value;\n\n    if (conditionalEnv[condition] && conditionalEnv[condition].indexOf(value) === -1)\n      return false;\n\n    conditionalEnvVariations[condition] = conditionalEnvVariations[condition] || [];\n    if (conditionalEnvVariations[condition].indexOf(value) === -1)\n      conditionalEnvVariations[condition].push(value);\n\n    if (conditionModules.indexOf(conditionModule) == -1)\n      conditionModules.push(conditionModule);\n\n    return true;\n  }\n\n  // whether or not to include condition branch given our conditionalEnv\n  function booleanEnvTrace(condition) {\n    var conditionObj = parseCondition(condition);\n\n    if (conditionObj.negate)\n      return traceCondition(conditionalComplement(condition), false);\n    else\n      return traceCondition(condition, true);\n  }\n\n  // { condition, branch } boolean conditional\n  if (conditional.branch) {\n    branches.push(booleanEnvTrace(conditional.condition) ? conditional.branch: '@empty');\n  }\n\n  // { envs: [{condition, branch},...], fallback } package environment map\n  else if (conditional.envs) {\n    var doFallback = true;\n    conditional.envs.forEach(function(env) {\n      if (doFallback && booleanEnvTrace(env.condition))\n        branches.push(env.branch);\n\n      // if we're specifically not tracing the negative of this condition\n      // then we stop the fallback branch from building\n      if (!booleanEnvTrace(conditionalComplement(env.condition)))\n        doFallback = false;\n    });\n    if (doFallback && conditional.fallback)\n      branches.push(conditional.fallback);\n  }\n\n  // { condition, branches } conditional interpolation\n  else if (conditional.branches) {\n    Object.keys(conditional.branches).forEach(function(branch) {\n      if (traceCondition(conditional.condition, branch))\n        branches.push(conditional.branches[branch]);\n    });\n  }\n\n  return {\n    branches: branches,\n    conditionModules: conditionModules,\n    conditionalEnvVariations: conditionalEnvVariations\n  };\n};\n\n// Returns the ordered immediate dependency array from the trace of a module\nTrace.getLoadDependencies = function(load, traceOpts, canonicalConditionalEnv, canonicalInlineConditionals) {\n  canonicalConditionalEnv = canonicalConditionalEnv || {};\n\n  var deps = [];\n\n  // conditional load records have their branches all included in the trace\n  if (load.conditional) {\n    var resolutions = Trace.getConditionalResolutions(load.conditional, canonicalConditionalEnv, canonicalInlineConditionals);\n\n    if (traceOpts.tracePackageConfig && load.packageConfig)\n      deps.push(load.packageConfig);\n\n    resolutions.conditionModules.forEach(function(conditionModule) {\n      if (deps.indexOf(conditionModule) == -1)\n        deps.push(conditionModule);\n    });\n\n    return deps.concat(resolutions.branches);\n  }\n\n  // trace the plugin as a dependency\n  if (traceOpts.traceRuntimePlugin && load.runtimePlugin)\n    deps.push(load.plugin);\n\n  // plugins by syntax build in their config\n  if (traceOpts.tracePackageConfig && load.pluginConfig)\n    deps.push(load.pluginConfig);\n\n  // add the dependencies\n  load.deps.forEach(function(dep) {\n    deps.push(load.depMap[dep]);\n  });\n\n  // trace the package config if necessary\n  if (traceOpts.tracePackageConfig && load.packageConfig)\n    deps.push(load.packageConfig);\n\n  return deps;\n};\n","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/lib/output.js":"var path = require('path');\nvar mkdirp = require('mkdirp');\nvar fs = require('fs');\nvar Promise = require('bluebird');\nvar asp = require('bluebird').promisify;\nvar extend = require('./utils').extend;\n\nvar fromFileURL = require('./utils').fromFileURL;\nvar toFileURL = require('./utils').toFileURL;\n\nfunction countLines(str) {\n  return str.split(/\\r\\n|\\r|\\n/).length;\n}\n\n// Process compiler outputs, gathering:\n//\n//   concatOutputs:         list of source strings to concatenate\n//   sourceMapsWithOffsets: list of [absolute offset,\n//                                   source map string] pairs\n//\n//  Takes lists as empty references and populates via push.\nfunction processOutputs(outputs) {\n  var removeSourceMaps = require('./sourcemaps').removeSourceMaps;\n\n  var offset = 0;\n\n  var outputObj = {};\n\n  var sources = outputObj.sources = [];\n  var sourceMapsWithOffsets = outputObj.sourceMapsWithOffsets = [];\n\n  outputs.forEach(function(output) {\n    var source;\n    if (typeof output == 'object') {\n      source = output.source || '';\n      var offset_ = output.sourceMapOffset || 0;\n      var map = output.sourceMap;\n      if (map) {\n        sourceMapsWithOffsets.push([offset + offset_, map]);\n      }\n    }\n    // NB perhaps we should enforce output is always an object down the chain?\n    else if (typeof output == 'string') {\n      source = output;\n    }\n    else {\n      var format = output ? output.toString() : typeof output;\n      throw new Error(\"Unexpected output format: \" + format);\n    }\n    source = removeSourceMaps(source || '');\n    offset += countLines(source);\n    sources.push(source);\n  });\n\n  return outputObj;\n}\n\nfunction createOutput(outFile, outputs, basePath, sourceMaps, sourceMapContents) {\n  var concatenateSourceMaps = require('./sourcemaps').concatenateSourceMaps;\n\n  var outputObj = processOutputs(outputs);\n\n  if (sourceMaps)\n    var sourceMap = concatenateSourceMaps(outFile, outputObj.sourceMapsWithOffsets, basePath, sourceMapContents);\n\n  var output = outputObj.sources.join('\\n');\n\n  return {\n    source: output,\n    sourceMap: sourceMap\n  };\n}\n\nfunction minify(output, fileName, mangle, uglifyOpts) {\n  var uglify = require('uglify-js');\n  var ast;\n  try{\n    ast = uglify.parse(output.source, { filename: fileName });\n  } catch(e){\n    throw new Error(e);\n  }\n  ast.figure_out_scope();\n  \n  ast = ast.transform(uglify.Compressor(uglifyOpts.compress));\n  ast.figure_out_scope();\n  if (mangle !== false)\n    ast.mangle_names();\n\n  var sourceMap;\n  if (output.sourceMap) {\n    if (typeof output.sourceMap === 'string')\n      output.sourceMap = JSON.parse(output.sourceMap);\n\n    var sourceMapIn = output.sourceMap;\n    sourceMap = uglify.SourceMap({\n      file: fileName,\n      orig: sourceMapIn\n    });\n\n    if (uglifyOpts.sourceMapIncludeSources && sourceMapIn && Array.isArray(sourceMapIn.sourcesContent)) {\n      sourceMapIn.sourcesContent.forEach(function(content, idx) {\n        sourceMap.get().setSourceContent(sourceMapIn.sources[idx], content);\n      });\n    }\n  }\n\n  var outputOptions = uglifyOpts.beautify;\n  // keep first comment\n  outputOptions.comments = outputOptions.comments || function(node, comment) {\n    return comment.line === 1 && comment.col === 0;\n  };\n  outputOptions.source_map = sourceMap;\n\n  output.source = ast.print_to_string(outputOptions);\n  output.sourceMap = sourceMap;\n\n  return output;\n}\n\nfunction writeOutputFile(outFile, source, sourceMap) {\n  var outDir = path.dirname(outFile);\n\n  return asp(mkdirp)(path.dirname(outFile))\n  .then(function() {\n    if (!sourceMap)\n      return;\n\n    var sourceMapFileName = path.basename(outFile) + '.map';\n    source += '\\n//# sourceMappingURL=' + sourceMapFileName;\n    \n    return asp(fs.writeFile)(path.resolve(outDir, sourceMapFileName), sourceMap);\n  })\n  .then(function() {\n    return asp(fs.writeFile)(outFile, source);\n  });\n}\n\nexports.inlineSourceMap = inlineSourceMap;\nfunction inlineSourceMap(source, sourceMap) {\n  if (!sourceMap)\n    throw new Error('NOTHING TO INLINE');\n  return source + '\\n//# sourceMappingURL=data:application/json;base64,'\n      + new Buffer(sourceMap.toString()).toString('base64');\n}\n\nexports.writeOutputs = function(outputs, baseURL, outputOpts) {\n  var outFile = outputOpts.outFile && path.resolve(outputOpts.outFile);\n  var basePath = fromFileURL(baseURL);\n  var fileName = outFile && path.basename(outFile) || 'output.js';\n\n  var output = createOutput(outFile || path.resolve(basePath, fileName), outputs, basePath, outputOpts.sourceMaps, outputOpts.sourceMapContents);\n\t\n  if (outputOpts.minify)\n    output = minify(output, fileName, outputOpts.mangle, outputOpts.uglify);\n\n  if (outputOpts.sourceMaps == 'inline') {\n    output.source = inlineSourceMap(output.source, output.sourceMap);\n    output.sourceMap = undefined;\n  }\n\n  if (!outputOpts.outFile)\n    return Promise.resolve(output);\n\n  return writeOutputFile(outFile, output.source, output.sourceMap).then(function() {\n    return output;\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/compilers/amd.js":"var vm = require('vm');\nvar compiler = require('./compiler');\nvar Promise = require('bluebird');\n\n// override System instantiate to handle AMD dependencies\nexports.attach = function (loader) {\n  var systemInstantiate = loader.instantiate;\n  loader.instantiate = function (load) {\n    var loader = this;\n\n    return systemInstantiate.call(this, load).then(function (result) {\n      if (load.metadata.format == 'amd') {\n\n        if (!load.source) load.source = ' ';\n\n        var output = compiler.compileAst(load, [require('babel-plugin-transform-amd-system-wrapper').default, { filterMode: true }]);\n        load.metadata.ast = output.ast;\n        load.metadata.anonNamed = output.metadata.anonNamed;\n\n        var entry = loader.defined[load.name];\n        entry.deps = dedupe(output.metadata.amdDeps.concat(load.metadata.deps));\n\n        load.metadata.builderExecute = function (require, exports, module) {\n          var removeDefine = loader.get('@@amd-helpers').createDefine(loader);\n\n          // NB source maps, System overwriting skipped here\n          vm.runInThisContext(load.source);\n\n          removeDefine(loader);\n\n          var lastModule = loader.get('@@amd-helpers').lastModule;\n\n          if (!lastModule.anonDefine && !lastModule.isBundle)\n            throw new TypeError('AMD module ' + load.name + ' did not define');\n\n          if (lastModule.anonDefine)\n            return lastModule.anonDefine.execute.apply(this, arguments);\n\n          lastModule.isBundle = false;\n          lastModule.anonDefine = null;\n        };\n\n        // first, normalize all dependencies\n        var normalizePromises = [];\n        for (var i = 0, l = entry.deps.length; i < l; i++) {\n          normalizePromises.push(Promise.resolve(loader.normalize(entry.deps[i], load.name)));\n        }\n\n        return Promise.all(normalizePromises).then(function (normalizedDeps) {\n          entry.normalizedDeps = normalizedDeps;\n          entry.originalIndices = group(entry.deps);\n\n          return {\n            deps: entry.deps,\n            execute: result.execute\n          };\n        });\n      }\n\n      return result;\n    });\n  };\n};\n\nfunction dedupe(deps) {\n  var newDeps = [];\n  for (var i = 0, l = deps.length; i < l; i++)\n    if (newDeps.indexOf(deps[i]) == -1)\n      newDeps.push(deps[i])\n  return newDeps;\n}\n\nfunction group(deps) {\n  var names = [];\n  var indices = [];\n  for (var i = 0, l = deps.length; i < l; i++) {\n    var index = names.indexOf(deps[i]);\n    if (index === -1) {\n      names.push(deps[i]);\n      indices.push([i]);\n    }\n    else {\n      indices[index].push(i);\n    }\n  }\n  return { names: names, indices: indices };\n}\n\n// converts anonymous AMDs into named AMD for the module\nexports.compile = function (load, opts, loader) {\n  opts.moduleId = !opts.anonymous && load.name;\n  return compiler.compile(load, opts, [require('babel-plugin-transform-amd-system-wrapper').default, {\n    anonNamed: load.metadata.anonNamed,\n    map: function (dep) {\n      return opts.normalize ? load.depMap[dep] : dep;\n    },\n    systemGlobal: opts.systemGlobal,\n\t  deps: load.deps\n  }]);\n};\n","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/compilers/compiler.js":"var path = require('path');\nvar babel = require('babel-core');\n\nfunction pathToUrl(p) {\n  return p.replace(/\\\\/g, '/');\n}\n\nexports.compile = function (load, opts, plugin) {\n  var sourceRoot = pathToUrl(path.dirname(load.path) + '/');\n  var options = {\n    babelrc: false,\n    compact: false,\n    sourceType: 'script',\n    filename: pathToUrl(load.path),\n    filenameRelative: path.basename(load.path),\n    inputSourceMap: load.metadata.sourceMap,\n    moduleId: opts.moduleId,\n    sourceFileName: load.path && path.basename(load.path),\n    sourceMaps: !!opts.sourceMaps,\n    sourceRoot: sourceRoot,\n    plugins: [plugin]\n  };\n\n  var source = load.metadata.originalSource || load.source;\n\n  var output;\n  if (load.metadata.ast) {\n    output = babel.transformFromAst(load.metadata.ast, source, options);\n  } else {\n    output = babel.transform(source, options);\n  }\n\n  var sourceMap = output.map;\n  if (sourceMap && !sourceMap.sourceRoot) // if input source map doesn't have sourceRoot - add it\n    sourceMap.sourceRoot = sourceRoot;\n\n  return Promise.resolve({\n    source: output.code,\n    sourceMap: sourceMap\n  });\n};\n\nexports.compileAst = function (load, plugin) {\n  return babel.transform(load.source, {\n      babelrc: false,\n      compact: false,\n      filename: load.path,\n      inputSourceMap: load.metadata.sourceMap,\n      ast: true,\n      plugins: [plugin]\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/compilers/cjs.js":"var compiler = require('./compiler');\n\nexports.compile = function (load, opts, loader) {\n\n  opts.moduleId = !opts.anonymous && load.name;\n\n  var deps = opts.normalize ? load.deps.map(function (dep) { return load.depMap[dep]; }) : load.deps;\n\n  // send normalized globals into the transformer\n  var normalizedGlobals;\n  if (load.metadata.globals) {\n    normalizedGlobals = {};\n    for (var g in load.metadata.globals)\n      normalizedGlobals[g] = opts.normalize ? load.depMap[load.metadata.globals[g]] : load.metadata.globals[g];\n  }\n\n  // remove loader base url from path\n  var path;\n  if (opts.static) {\n    path = load.path;\n    if (path.substr(0, loader.baseURL.length) == loader.baseURL)\n      path = path.substr(loader.baseURL.length);\n  }\n\n  return compiler.compile(load, opts, [require('babel-plugin-transform-cjs-system-wrapper').default, {\n    deps: deps,\n    globals: normalizedGlobals,\n    optimize: opts.production,\n    map: function(dep) {\n      return opts.normalize ? load.depMap[dep] : dep;\n    },\n    path: path,\n    static: opts.static,\n    systemGlobal: opts.systemGlobal\n  }]);\n};\n","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/compilers/esm.js":"var traceur = require('traceur');\nvar traceurGet = require('../lib/utils').traceurGet;\n\nvar ParseTreeTransformer = traceurGet('codegeneration/ParseTreeTransformer.js').ParseTreeTransformer;\nvar ModuleSpecifier = traceurGet('syntax/trees/ParseTrees.js').ModuleSpecifier;\nvar createStringLiteralToken = traceurGet('codegeneration/ParseTreeFactory.js').createStringLiteralToken;\nvar InstantiateModuleTransformer = traceurGet('codegeneration/InstantiateModuleTransformer.js').InstantiateModuleTransformer;\n\nvar extend = require('../lib/utils').extend;\n\n// patch pending https://github.com/google/traceur-compiler/pull/2053\nvar createUseStrictDirective = traceurGet('codegeneration/ParseTreeFactory.js').createUseStrictDirective;\nInstantiateModuleTransformer.prototype.__proto__.moduleProlog = function() {\n  return [createUseStrictDirective()];\n};\n\n\nvar CollectingErrorReporter = traceurGet('util/CollectingErrorReporter.js').CollectingErrorReporter;\nvar UniqueIdentifierGenerator = traceurGet('codegeneration/UniqueIdentifierGenerator.js').UniqueIdentifierGenerator;\n\nfunction TraceurImportNormalizeTransformer(map) {\n  this.map = map;\n  return ParseTreeTransformer.apply(this, arguments);\n}\nTraceurImportNormalizeTransformer.prototype = Object.create(ParseTreeTransformer.prototype);\nTraceurImportNormalizeTransformer.prototype.transformModuleSpecifier = function(tree) {\n  var depName = this.map(tree.token.processedValue) || tree.token.processedValue;\n\n  return new ModuleSpecifier(tree.location, createStringLiteralToken(depName));\n};\n\nexports.TraceurImportNormalizeTransformer = TraceurImportNormalizeTransformer;\n\n\nfunction remap(source, map, fileName) {\n  var compiler = new traceur.Compiler();\n\n  var tree = compiler.parse(source, fileName);\n\n  tree = new TraceurImportNormalizeTransformer(map).transformAny(tree);\n\n  return Promise.resolve({\n    source: compiler.write(tree)\n  });\n}\nexports.remap = remap;\n\n// override System instantiate to handle esm tracing\nexports.attach = function(loader) {\n  var systemInstantiate = loader.instantiate;\n  loader.instantiate = function(load) {\n    // skip plugin loader attachment || non es modules || es modules handled by internal transpilation layer\n    if (!loader.builder || load.metadata.format != 'esm' || load.metadata.originalSource)\n      return systemInstantiate.call(this, load);\n\n    var depsList = load.metadata.deps.concat([]);\n\n    var babel = require('babel-core');\n    var output = babel.transform(load.source, {\n      babelrc: false,\n      compact: false,\n      filename: load.path,\n      //sourceFileName: load.path,\n      inputSourceMap: load.metadata.sourceMap,\n      ast: true,\n      resolveModuleSource: function(dep) {\n        if (depsList.indexOf(dep) == -1)\n          depsList.push(dep);\n        return dep;\n      }\n    });\n    // turn back on comments (for some reason!)\n    output.ast.comments.forEach(function(comment) {\n      comment.ignore = false;\n    });\n    load.metadata.ast = output.ast;\n\n    return Promise.resolve({\n      deps: depsList,\n      execute: null\n    });\n  };\n};\n\nvar versionCheck = true;\n\nexports.compile = function(load, opts, loader) {\n  if (!load.metadata.originalSource || load.metadata.loader && load.metadata.format == 'esm') {\n    var babel = require('babel-core');\n\n    var babelOptions = {\n      babelrc: false,\n      compact: false,\n      plugins: [[require('babel-plugin-transform-es2015-modules-systemjs'), { systemGlobal: opts.systemGlobal }]],\n      filename: load.path,\n      //sourceFileName: load.path,\n      sourceMaps: !!opts.sourceMaps,\n      inputSourceMap: load.metadata.sourceMap,\n      moduleIds: !opts.anonymous,\n      moduleId: !opts.anonymous && load.name,\n      code: true,\n      resolveModuleSource: function(dep) {\n        if (opts.normalize)\n          return load.depMap[dep];\n        else\n          return dep;\n      }\n    };\n\n    var source = load.metadata.originalSource || load.source;\n\n    var output;\n    if (load.metadata.ast)\n      output = babel.transformFromAst(load.metadata.ast, source, babelOptions);\n    else\n      output = babel.transform(source, babelOptions);\n\n    // NB this can be removed with merging of ()\n    if (opts.systemGlobal != 'System')\n      output.code = output.code.replace(/(\\s|^)System\\.register\\(/, '$1' + opts.systemGlobal + '.register(');\n\n    // for some reason Babel isn't respecting sourceFileName...\n    if (output.map && !load.metadata.sourceMap)\n      output.map.sources[0] = load.path;\n\n    return Promise.resolve({\n      source: output.code,\n      sourceMap: output.map\n    });\n  }\n\n  // ... legacy transpilation, to be deprecated with internal transpilation layer\n  return Promise.resolve(global[loader.transpiler == 'typescript' ? 'ts' : loader.transpiler] || loader.pluginLoader.import(loader.transpiler))\n  .then(function(transpiler) {\n    if (transpiler.__useDefault)\n      transpiler = transpiler['default'];\n\n    if (transpiler.Compiler) {\n      var options = loader.traceurOptions || {};\n      options.modules = 'instantiate';\n      options.script = false;\n      options.sourceRoot = true;\n      options.moduleName = !opts.anonymous;\n\n      if (opts.sourceMaps)\n        options.sourceMaps = 'memory';\n      if (opts.lowResSourceMaps)\n        options.lowResolutionSourceMap = true;\n\n      if (load.metadata.sourceMap)\n        options.inputSourceMap = load.metadata.sourceMap;\n\n      var compiler = new transpiler.Compiler(options);\n\n      var tree = compiler.parse(load.source, load.path);\n\n      var transformer = new TraceurImportNormalizeTransformer(function(dep) {\n        return opts.normalize ? load.depMap[dep] : dep;\n      });\n\n      tree = transformer.transformAny(tree);\n\n      tree = compiler.transform(tree, load.name);\n\n      var outputSource = compiler.write(tree, load.path);\n\n      if (outputSource.match(/\\$traceurRuntime/))\n        load.metadata.usesTraceurRuntimeGlobal = true;\n\n      return Promise.resolve({\n        source: outputSource,\n        sourceMap: compiler.getSourceMap()\n      });\n    }\n    else if (transpiler.createLanguageService) {\n      var options = loader.typescriptOptions || {};\n      if (options.target === undefined)\n        options.target = transpiler.ScriptTarget.ES5;\n      options.module = transpiler.ModuleKind.System;\n\n      var transpileOptions = {\n        compilerOptions: options,\n        renamedDependencies: load.depMap,\n        fileName: load.path,\n        moduleName: !opts.anonymous && load.name\n      };\n\n      var transpiled = transpiler.transpileModule(load.source, transpileOptions);\n\n      return Promise.resolve({\n        source: transpiled.outputText,\n        sourceMap: transpiled.sourceMapText\n      });\n    }\n    else {\n      if (versionCheck) {\n        var babelVersion = transpiler.version;\n        if (babelVersion.split('.')[0] > 5)\n          console.log('Warning - using Babel ' + babelVersion + '. This version of SystemJS builder is designed to run against Babel 5.');\n        versionCheck = false;\n      }\n\n      var options = extend({}, loader.babelOptions || {});\n      options.modules = 'system';\n      if (opts.sourceMaps)\n        options.sourceMap = true;\n      if (load.metadata.sourceMap)\n        options.inputSourceMap = load.metadata.sourceMap;\n      options.filename = load.path;\n      options.filenameRelative = load.name;\n      options.sourceFileName = load.path;\n      options.keepModuleIdExtensions = true;\n      options.code = true;\n      options.ast = false;\n      options.moduleIds = !opts.anonymous;\n      options.externalHelpers = true;\n\n      if (transpiler.version.match(/^4/))\n        options.returnUsedHelpers = true;\n      else if (transpiler.version.match(/^5\\.[01234]\\./))\n        options.metadataUsedHelpers = true;\n\n      if (opts.normalize)\n        options.resolveModuleSource = function(dep) {\n          return load.depMap[dep] || dep;\n        };\n\n      var output = transpiler.transform(load.source, options);\n\n      var usedHelpers = output.usedHelpers || output.metadata && output.metadata.usedHelpers;\n\n      if ((!options.optional || options.optional.indexOf('runtime') == -1) && usedHelpers.length)\n        load.metadata.usesBabelHelpersGlobal = true;\n\n      // pending Babel v5, we need to manually map the helpers\n      if (options.optional && options.optional.indexOf('runtime') != -1)\n        load.deps.forEach(function(dep) {\n          if (dep.match(/^babel-runtime/))\n            output.code = output.code.replace(dep, load.depMap[dep]);\n        });\n\n      // clear options for reuse\n      delete options.filenameRelative;\n      delete options.sourceFileName;\n\n      return Promise.resolve({\n        source: output.code,\n        sourceMap: output.map\n      });\n    }\n  })\n  .then(function(output) {\n    if (opts.systemGlobal != 'System')\n      output.source = output.source.replace(/System\\.register\\(/, opts.systemGlobal + '.register(');\n    return output;\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/compilers/global.js":"var compiler = require('./compiler');\n\nexports.compile = function (load, opts, loader) {\n  var deps = opts.normalize ? load.deps.map(function(dep) { return load.depMap[dep]; }) : load.deps;\n\n  // send normalized globals into the transformer\n  var normalizedGlobals;\n  if (load.metadata.globals) {\n    normalizedGlobals = {};\n    for (var g in load.metadata.globals)\n      normalizedGlobals[g] = opts.normalize ? load.depMap[load.metadata.globals[g]] : load.metadata.globals[g];\n  }\n\n  return compiler.compile(load, opts, [require('babel-plugin-transform-global-system-wrapper').default, {\n    deps: deps,\n    exportName: load.metadata.exports,\n    globals: normalizedGlobals,\n    moduleName: !opts.anonymous && load.name,\n    systemGlobal: opts.systemGlobal\n  }]);\n};\n\nexports.sfx = function(loader) {\n  return require('fs').readFileSync(require('path').resolve(__dirname, '../templates/global-helpers.min.js')).toString();\n};\n","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/compilers/json.js":"function hasProperties(obj) {\n  for (var p in obj)\n    return true;\n  return false;\n}\n\nexports.compile = function(load, opts, loader) {\n  try {\n    var json = JSON.parse(load.source)\n  }\n  catch(e) {\n    throw new Error('Unable to parse JSON module ' + load.name + ' contents as JSON.');\n  }\n\n  if (load.isPackageConfig)\n    json = optimizePackageConfig(json);\n\n  return Promise.resolve({\n    source: opts.systemGlobal + '.registerDynamic(' + (opts.anonymous ? '' : '\"' + load.name + '\", ') + '[], true, function() {\\n' +\n            '  return ' + JSON.stringify(json, null, 2).replace(/\\n/g, '\\n  ') + ';\\n' +\n            '});\\n'\n  });\n};\n\n// because bundles are for the browser only\n// if this is a package config file json we are compiling\n// then we can optimize out the node-only configurations to make it smaller\nfunction optimizePackageConfig(json) {\n  if (json.systemjs)\n    json = json.systemjs;\n\n  // remove non SystemJS package config properties\n  var loaderConfigProperties = ['baseDir', 'defaultExtension', 'format', 'meta', 'map', 'main'];\n  for (var p in json)\n    if (loaderConfigProperties.indexOf(p) == -1)\n      delete json[p];\n\n  if (json.map && !json.map['@env']) {\n    Object.keys(json.map).forEach(function(target) {\n      var mapped = json.map[target];\n\n      if (typeof mapped == 'string' && mapped.substr(0, 6) == '@node/')\n        delete json.map[target];\n\n      if (typeof mapped == 'object') {\n        Object.keys(mapped).forEach(function(condition) {\n          if (condition == 'node')\n            delete mapped[condition];\n        });\n        if (!hasProperties(mapped))\n          delete json.map[target];\n      }\n    });\n\n    if (!hasProperties(json.map))\n      delete json.map;\n  }\n\n  return json;\n}\n","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/compilers/register.js":"var compiler = require('./compiler');\n\nexports.compile = function (load, opts, loader) {\n  return compiler.compile(load, opts, [require('babel-plugin-transform-system-register').default, {\n    moduleName: !opts.anonymous && load.name,\n    map: function (dep) {\n      return opts.normalize ? load.depMap[dep] : dep;\n    },\n    systemGlobal: opts.systemGlobal\n  }]);\n};\n","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/lib/get-deferred-imports.js":"var traceur = require('traceur');\n\nvar traceurGet = require('./utils').traceurGet;\n\nvar ParseTreeTransformer = traceurGet('codegeneration/ParseTreeTransformer.js').ParseTreeTransformer;\n\nvar getCanonicalName = require('./utils').getCanonicalName;\n\nvar Promise = require('bluebird');\n\nfunction DeferredImportsTransformer(map) {\n  this.imports = [];\n  return ParseTreeTransformer.apply(this, arguments);\n}\n\nDeferredImportsTransformer.prototype = Object.create(ParseTreeTransformer.prototype);\n\nDeferredImportsTransformer.prototype.transformCallExpression = function(tree) {\n  tree = ParseTreeTransformer.prototype.transformCallExpression.call(this, tree);\n\n  if (tree.operand.type == 'MEMBER_EXPRESSION'\n      && tree.operand.memberName.value == 'import'\n      && tree.operand.operand.type == 'IDENTIFIER_EXPRESSION'\n      && tree.operand.operand.identifierToken.value == 'System'\n      && tree.args.args.length == 1) {\n\n    if (tree.args.args[0].type === 'LITERAL_EXPRESSION')\n      this.imports.push(tree.args.args[0].literalToken.processedValue);\n  }\n\n  return tree;\n}\n\nmodule.exports = function(builder, trace) {\n  var deferredImports = [];\n\n  return Promise.all(Object.keys(trace).map(function(name) {\n    var load = trace[name];\n\n    if (load.deferredImports) {\n      deferredImports = deferredImports.concat(load.deferredImports);\n      return;\n    }\n\n    var curDeferredImports = [];\n\n    if (!load || load.conditional)\n      return;\n\n    var compiler = new traceur.Compiler({ script: load.metadata.format !== 'esm' });\n\n    var tree = compiler.parse(load.source, load.path);\n\n    var transformer = new DeferredImportsTransformer();\n\n    tree = transformer.transformAny(tree);\n\n    return Promise.all(transformer.imports.map(function(impt) {\n      return builder.loader.normalize(impt)\n      .then(function(moduleName) {\n        var canonical = getCanonicalName(builder.loader, moduleName);\n\n        curDeferredImports.push({\n          name: canonical,\n          parent: name\n        });\n      });\n    }))\n    .then(function() {\n      // store on the load record itself to allow caching\n      load.deferredImports = curDeferredImports;\n      deferredImports = deferredImports.concat(curDeferredImports);\n    });\n  }))\n  .then(function() {\n    return deferredImports;\n  });\n};","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/lib/sourcemaps.js":"var sourceMap = require('source-map');\nvar path = require('path');\nvar fs = require('fs');\n\nvar toFileURL = require('./utils').toFileURL;\nvar fromFileURL = require('./utils').fromFileURL;\n\nvar wrapSourceMap = function(map) {\n  return new sourceMap.SourceMapConsumer(map);\n};\n\nvar sourceMapRegEx = /^\\s*\\/\\/[@#] ?(sourceURL|sourceMappingURL)=([^\\n'\"]+)/m;\nexports.removeSourceMaps = function(source) {\n  return source.replace(sourceMapRegEx, '');\n};\n\nfunction getMapObject(map) {\n  if (typeof map != 'string')\n    return map;\n\n  try {\n    return JSON.parse(map);\n  }\n  catch(error) {\n    throw new Error('Invalid JSON: ' + map);\n  }\n}\n\nfunction isFileURL(url) {\n  return url.substr(0, 8) == 'file:///';\n}\n\nexports.concatenateSourceMaps = function(outFile, mapsWithOffsets, basePath, sourceMapContents) {\n  var generated = new sourceMap.SourceMapGenerator({\n    file: path.basename(outFile)\n  });\n\n  var outPath = path.dirname(outFile);\n\n  var contentsBySource = sourceMapContents ? {} : null;\n\n  mapsWithOffsets.forEach(function(pair) {\n    var offset = pair[0];\n    var map = getMapObject(pair[1]);\n\n    if (sourceMapContents && map.sourcesContent) {\n      for (var i=0; i<map.sources.length; i++) {\n        var source = (map.sourceRoot || '') + map.sources[i];\n        if (!source.match(/\\/@traceur/)) {\n          if (!contentsBySource[source]) {\n            contentsBySource[source] = map.sourcesContent[i];\n          } else {\n            if (contentsBySource[source] != map.sourcesContent[i]) {\n              throw new Error(\"Mismatched sourcesContent for: \" + source);\n            }\n          }\n        }\n      }\n    }\n\n    wrapSourceMap(map).eachMapping(function(mapping) {\n      if (mapping.originalLine == null || mapping.originalColumn == null || !mapping.source || mapping.source.match(/(\\/|^)@traceur/))\n        return;\n\n      generated.addMapping({\n        generated: {\n          line: offset + mapping.generatedLine,\n          column: mapping.generatedColumn\n        },\n        original: {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        },\n        source: mapping.source,\n        name: mapping.name\n      });\n    });\n  });\n\n  // normalize source paths and inject sourcesContent if necessary\n  var normalized = JSON.parse(JSON.stringify(generated));\n\n  if (sourceMapContents) {\n    normalized.sourcesContent = normalized.sources.map(function(source) {\n      if (contentsBySource[source])\n        return contentsBySource[source];\n\n      try {\n        return fs.readFileSync(path.resolve(basePath, source)).toString();\n      }\n      catch (e) {\n        return \"\";\n      }\n    });\n  }\n\n  normalized.sources = normalized.sources.map(function(source) {\n    if (isFileURL(source))\n      source = fromFileURL(source);\n\n    return path.relative(outPath, path.resolve(basePath, source)).replace(/\\\\/g, '/');\n  });\n\n  return JSON.stringify(normalized);\n};\n","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/templates/global-helpers.js":"(function (global) {\n  var loader = $__System;\n\n  function readMemberExpression (p, value) {\n    var pParts = p.split('.');\n    while (pParts.length)\n      value = value[pParts.shift()];\n    return value;\n  }\n\n  function getGlobalValue (exports) {\n    if (typeof exports == 'string')\n      return readMemberExpression(exports, global);\n\n    if (!(exports instanceof Array))\n      throw new Error('Global exports must be a string or array.');\n\n    var globalValue = {};\n    for (var i = 0; i < exports.length; i++)\n      globalValue[exports[i].split('.').pop()] = readMemberExpression(exports[i], global);\n    return globalValue;\n  }\n\n  // bare minimum ignores\n  var ignoredGlobalProps = ['_g', 'sessionStorage', 'localStorage', 'clipboardData', 'frames', 'frameElement', 'external',\n      'mozAnimationStartTime', 'webkitStorageInfo', 'webkitIndexedDB', 'mozInnerScreenY', 'mozInnerScreenX'];\n\n  var globalSnapshot;\n  function globalIterator (globalName) {\n    if (ignoredGlobalProps.indexOf(globalName) !== -1)\n      return;\n    try {\n      var value = global[globalName];\n    }\n    catch (e) {\n      ignoredGlobalProps.push(globalName);\n    }\n    this(globalName, value);\n  }\n\n  loader.registry.set('@@global-helpers', loader.newModule({\n    prepareGlobal: function (moduleName, exports, globals) {\n      // disable module detection\n      var curDefine = global.define;\n      global.define = undefined;\n\n      // set globals\n      var oldGlobals;\n      if (globals) {\n        oldGlobals = {};\n        for (var g in globals) {\n          oldGlobals[g] = global[g];\n          global[g] = globals[g];\n        }\n      }\n\n      // store a complete copy of the global object in order to detect changes\n      if (!exports) {\n        globalSnapshot = {};\n\n        Object.keys(global).forEach(globalIterator, function (name, value) {\n          globalSnapshot[name] = value;\n        });\n      }\n\n      // return function to retrieve global\n      return function () {\n        var globalValue = exports ? getGlobalValue(exports) : {};\n\n        var singleGlobal;\n        var multipleExports = !!exports;\n\n        if (!exports)\n          Object.keys(global).forEach(globalIterator, function (name, value) {\n            if (globalSnapshot[name] === value)\n              return;\n            if (value === undefined)\n              return;\n\n            if (!exports) {\n              globalValue[name] = value;\n\n              if (singleGlobal !== undefined) {\n                if (!multipleExports && singleGlobal !== value)\n                  multipleExports = true;\n              }\n              else {\n                singleGlobal = value;\n              }\n            }\n          });\n\n        globalValue = multipleExports ? globalValue : singleGlobal;\n\n        // revert globals\n        if (oldGlobals) {\n          for (var g in oldGlobals)\n            global[g] = oldGlobals[g];\n        }\n        global.define = curDefine;\n\n        return globalValue;\n      };\n    }\n  }));\n})(typeof self != 'undefined' ? self : global);\n","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/templates/sfx-amd.js":"(function(factory) {\n  define(${JSON.stringify(deps)}, factory);\n});","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/templates/sfx-cjs.js":"(function(factory) {\n  module.exports = factory(${deps.map(function(dep) {\n    return 'require(\"' + dep + '\")';\n  }).join(', ')});\n});","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/templates/sfx-core.js":"(function (global) {\n  var registry = {};\n\n  var BASE_OBJECT = typeof Symbol !== 'undefined' ? Symbol() : '@@baseObject';\n\n  function extendNamespace (key) {\n    Object.defineProperty(this, key, {\n      enumerable: true,\n      get: function () {\n        return this[BASE_OBJECT][key];\n      }\n    });\n  }\n\n  function createExternalModule (exports) {\n    var esModule;\n\n    // CJS es module -> lift into namespace\n    if (exports && exports.__esModule) {\n      esModule = {};\n      for (var p in exports) {\n        if (Object.hasOwnProperty.call(exports, p))\n          esModule[p] = exports[p];\n      }\n      if (esModule.__useDefault)\n        delete esModule.__useDefault;\n      esModule.__esModule = true;\n    }\n\n    // a real ES module or SystemJS ES Module\n    else if (Object.prototype.toString.call(exports) === '[object Module]' ||\n        typeof System !== 'undefined' && System.isModule && System.isModule(exports)) {\n      return exports;\n    }\n\n    // use default representation only\n    else {\n      esModule = { default: exports, __useDefault: true };\n    }\n    return new Module(esModule);\n  }\n\n  function Module (bindings) {\n    Object.defineProperty(this, BASE_OBJECT, {\n      value: bindings\n    });\n    Object.keys(bindings).forEach(extendNamespace, this);\n  }\n  Module.prototype = Object.create(null);\n  if (typeof Symbol !== 'undefined' && Symbol.toStringTag)\n    Module.prototype[Symbol.toStringTag] = 'Module';\n\n  var nodeRequire = typeof System != 'undefined' && System._nodeRequire || typeof require != 'undefined' && typeof require.resolve != 'undefined' && typeof process != 'undefined' && process.platform && require;\n\n  function getLoad (key) {\n    if (key.substr(0, 6) === '@node/')\n      return defineModule(key, createExternalModule(nodeRequire(key.substr(6))), {});\n    else\n      return registry[key];\n  }\n\n  function load (key) {\n    var load = getLoad(key);\n\n    if (!load)\n      throw new Error('Module \"' + key + '\" expected, but not contained in build.');\n\n    if (load.module)\n      return load.module;\n\n    var link = load.linkRecord;\n\n    instantiate(load, link);\n\n    doEvaluate(load, link, []);\n\n    return load.module;\n  }\n\n  function instantiate (load, link) {\n    // circular stop condition\n    if (link.depLoads)\n      return;\n\n    if (link.declare)\n      registerDeclarative(load, link);\n\n    link.depLoads = [];\n    for (var i = 0; i < link.deps.length; i++) {\n      var depLoad = getLoad(link.deps[i]);\n      link.depLoads.push(depLoad);\n      if (depLoad.linkRecord)\n        instantiate(depLoad, depLoad.linkRecord);\n\n      var setter = link.setters && link.setters[i];\n      if (setter) {\n        setter(depLoad.module || depLoad.linkRecord.moduleObj);\n        depLoad.importerSetters.push(setter);\n      }\n    }\n\n    return load;\n  }\n\n  function registerDeclarative (load, link) {\n    var moduleObj = link.moduleObj;\n    var importerSetters = load.importerSetters;\n\n    var locked = false;\n\n    // closure especially not based on link to allow link record disposal\n    var declared = link.declare.call(global, function (name, value) {\n      // export setter propogation with locking to avoid cycles\n      if (locked)\n        return;\n\n      if (typeof name == 'object') {\n        for (var p in name)\n          if (p !== '__useDefault')\n            moduleObj[p] = name[p];\n      }\n      else {\n        moduleObj[name] = value;\n      }\n\n      locked = true;\n      for (var i = 0; i < importerSetters.length; i++)\n        importerSetters[i](moduleObj);\n      locked = false;\n\n      return value;\n    }, { id: load.key });\n\n    if (typeof declared !== 'function') {\n      link.setters = declared.setters;\n      link.execute = declared.execute;\n    }\n    else {\n      link.setters = [];\n      link.execute = declared;\n    }\n  }\n\n  function register (key, deps, declare) {\n    return registry[key] = {\n      key: key,\n      module: undefined,\n      importerSetters: [],\n      linkRecord: {\n        deps: deps,\n        depLoads: undefined,\n        declare: declare,\n        setters: undefined,\n        execute: undefined,\n        moduleObj: {}\n      }\n    };\n  };\n\n  function registerDynamic (key, deps, executingRequire, execute) {\n    return registry[key] = {\n      key: key,\n      module: undefined,\n      importerSetters: [],\n      linkRecord: {\n        deps: deps,\n        depLoads: undefined,\n        declare: undefined,\n        execute: execute,\n        executingRequire: executingRequire,\n        moduleObj: {\n          default: {},\n          __useDefault: true\n        },\n        setters: undefined\n      }\n    };\n  }\n\n  function makeDynamicRequire (deps, depLoads, seen) {\n    // we can only require from already-known dependencies\n    return function (name) {\n      for (var i = 0; i < deps.length; i++)\n        if (deps[i] === name) {\n          var depLoad = depLoads[i];\n          var depLink = depLoad.linkRecord;\n          var module;\n          if (depLink) {\n            if (seen.indexOf(depLoad) === -1)\n              module = doEvaluate(depLoad, depLink, seen);\n            else\n              module = depLink.moduleObj;\n          }\n          else {\n            module = depLoad.module;\n          }\n          return module.__useDefault ? module.default : module;\n        }\n    };\n  }\n\n  function doEvaluate (load, link, seen) {\n    seen.push(load);\n\n    if (load.module)\n      return load.module;\n\n    var err;\n\n    // es modules evaluate dependencies first\n    if (link.setters) {\n      for (var i = 0; i < link.deps.length; i++) {\n        var depLoad = link.depLoads[i];\n        var depLink = depLoad.linkRecord;\n\n        if (depLink && seen.indexOf(depLoad) === -1)\n          err = doEvaluate(depLoad, depLink, depLink.setters ? seen : []);\n      }\n\n      link.execute.call(nullContext);\n    }\n    else {\n      var module = { id: load.key };\n      var moduleObj = link.moduleObj;\n      Object.defineProperty(module, 'exports', {\n        configurable: true,\n        set: function (exports) {\n          moduleObj.default = exports;\n        },\n        get: function () {\n          return moduleObj.default;\n        }\n      });\n      var require = makeDynamicRequire(link.deps, link.depLoads, seen);\n\n      // evaluate deps first\n      if (!link.executingRequire)\n        for (var i = 0; i < link.deps.length; i++)\n          require(link.deps[i]);\n\n      var output = link.execute.call(global, require, moduleObj.default, module);\n      if (output !== undefined)\n        moduleObj.default = output;\n      else if (module.exports !== moduleObj.default)\n        moduleObj.default = module.exports;\n\n      // __esModule flag extension support\n      if (moduleObj.default && moduleObj.default.__esModule)\n        for (var p in moduleObj.default)\n          if (Object.hasOwnProperty.call(moduleObj.default, p) && p !== 'default')\n            moduleObj[p] = moduleObj.default[p];\n    }\n\n    var module = load.module = new Module(link.moduleObj);\n\n    if (!link.setters)\n      for (var i = 0; i < load.importerSetters.length; i++)\n        load.importerSetters[i](module);\n\n    return module;\n  }\n\n  // {} is the closest we can get to call(undefined)\n  var nullContext = {};\n  if (Object.freeze)\n    Object.freeze(nullContext);\n\n  function defineModule (name, module) {\n    return registry[name] = {\n      key: name,\n      module: module,\n      importerSetters: [],\n      linkRecord: undefined\n    };\n  }\n\n  return function (mains, depNames, exportDefault, declare) {\n    return function (formatDetect) {\n      formatDetect(function (deps) {\n        var System = {\n          _nodeRequire: nodeRequire,\n          register: register,\n          registerDynamic: registerDynamic,\n          registry: {\n            get: function (name) {\n              return registry[name].module;\n            },\n            set: defineModule\n          },\n          newModule: function (module) {\n            return new Module(module);\n          }\n        };\n\n        defineModule('@empty', new Module({}));\n\n        // register external dependencies\n        for (var i = 0; i < depNames.length; i++)\n          defineModule(depNames[i], createExternalModule(arguments[i], {}));\n\n        // register modules in this bundle\n        declare(System);\n\n        // load mains\n        var firstLoad = load(mains[0]);\n        if (mains.length > 1)\n          for (var i = 1; i < mains.length; i++)\n            load(mains[i]);\n\n        if (exportDefault)\n          return firstLoad.default;\n\n        if (firstLoad instanceof Module)\n          Object.defineProperty(firstLoad, '__esModule', {\n            value: true\n          });\n\n        return firstLoad;\n      });\n    };\n  };\n\n})(typeof self !== 'undefined' ? self : global)\n/* (['mainModule'], ['external-dep'], false, function($__System) {\n  System.register(...);\n})\n(function(factory) {\n  if (typeof define && define.amd)\n    define(['external-dep'], factory);\n  // etc UMD / module pattern\n})*/\n","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/templates/sfx-esm.js":"(function(factory) {\n  main = factory();\n});\n\nexport default main;","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/templates/sfx-global.js":"(function(factory) {\n  ${globalName ? globalName + ' = ' : ''}factory(${globalDeps.join(', ')});\n});","/home/travis/build/npmtest/node-npmtest-systemjs-builder/node_modules/systemjs-builder/templates/sfx-umd.js":"(function(factory) {\n  if (typeof define == 'function' && define.amd)\n    define(${JSON.stringify(deps)}, factory);\n  else if (typeof module == 'object' && module.exports && typeof require == 'function')\n    module.exports = factory(${deps.map(function(dep) {\n    return 'require(\"' + dep + '\")';\n  }).join(', ')});\n  else\n    ${ deps.length && !globalDeps.length\n      ? 'throw new Error(\"Module must be loaded as AMD or CommonJS\")'\n      : (globalName ? globalName + ' = ' : '') + 'factory(' + (globalDeps.length ? globalDeps.join(', ') : '') + ')'};\n});"}